\chapter{Physics Applications}

\section{The Standard Model.}

\subsection{A Photon One-Loop Self Energy Diagram}
\label{self}
The function \mb{OneLoop} performs the algebraic simplifications 
of a given amplitude. The result is given in a polynomial of standard 
matrix elements, invariants of the process under consideration, 
and Passarino-Veltman integrals.

\otabtwo{
\mbs{OneLoop[{\sl q},\ {\sl amp}]} & calculates the one-loop amplitude $amp$
with $q$ as  loop momentum\cr
\mbs{OneLoop[{\sl name},\ {\sl q},\ {\sl amp}]} & calculates the one-loop amplitude $amp$ 
and gives it a name
} {Calculating one-loop amplitudes.}

\otabtwo{
\mbs{PropagatorDenominator[ Momentum[{\sl q}],\ {\sl m}]} & a factor of the denominator of a propagator \cr
\mbs{PropagatorDenominator[ Momentum[{\sl q}, {\sl D}],\ {\sl m}]} & a factor of the denominator of a propagator in {\sl D} dimensions \cr
\mbs{FeynAmpDenominator[ PropagatorDenominator[ ... ],\ PropagatorDenominator[ ... ]]} & a propagator \cr
} {Representation of integrands.}

The first argument to \mb{OneLoop} is optional. It indicates  a name
for the amplitude for bookkeeping reasons. 
The second argument $q$ is the loop momentum, i.e., the integration 
variable. 

As last argument the analytical expression for the graph is given.      
It may be given in four dimensions. \mb{OneLoop} performs the 
necessary extension to $D$ dimensions automatically. 

\beom
\domtog{{-I/Pi\phat 2\ FeynAmpDenominator[\\
\ PropagatorDenominator[q,\ m]]\\
}}{-\Frac{\ComplexI}{\pi^2(q^2\ -\ m^2)}\hfil\\
}{
This is \\ $ A_0=- i \, \pi^{-2} \, (2\,\pi \mu)^{4-D} \,
\int d^{D}q\, (q^2 - m^{2})^{-1}$, \\
corresponding to a tadpole diagram.

The scaling variable $\mu$ is suppressed by 
\fc.
}
\domtog{{a0\ =\ OneLoop[q,\ a0]\\
}}{$A_0(m^2)$\hfil\\
}{
This calculates the tadpole diagram.
}
\dtog{{SetOptions[A0,\ A0ToB0\ $\Rule$\ True];\\
}}{}{
Have \mb{A0} written in terms of \mb{B0}.
}
\domtog{{OneLoop[q,\ a0]\\
}}{$m^2 B_0(0,\ m^2,\ m^2)\, +\, m^2$\hfil\\
}{
This calculates the tadpole diagram again. Now the result is given in terms of \mb{B0}.
}
\dtog{{SetOptions[A0,\ A0ToB0\ $\Rule$\ False];\\
}}{}{
Return to the default.
}
\dtog{{SetOptions[OneLoop,\ Factoring\ $\Rule$\ True];\\
}}{}{
To obtain a more compact result, the factoring option of \mb{OneLoop} is set.
For a description of all options of \mb{OneLoop} see section \ref{oneopt}.
}
\domtog{{OneLoop[\ q,\ (I\ el\phat 2)/(16\ Pi\phat 4)/(1\ -\ D)\ *\ \\
FeynAmpDenominator[\\
PropagatorDenominator[q,\ mf],\\
PropagatorDenominator[q\ -\ k,\ mf]\ ]\ *\\
DiracTrace[(mf\ +\ DiracSlash[q\ -\ k])\ .\ DiracMatrix[mu]\ .\\
(mf\ +\ DiracSlash[q])\ .\ DiracMatrix[mu]]\\
]\ /.\ ScalarProduct[k,\ k]\ $\Rule$\ k2\ /.\\
(mf\phat 2)\ $\Rule$\ mf2\\
}}{
\Frac{
{\rm el}^2\ \ (-{\rm k2}\ +6\ {\rm mf2}\ -\ 6\ A_0({\rm mf2})\ +\ 3\ ({\rm k2}\ +\ 2\ {\rm mf2})\ 
B_0({\rm k2},\ {\rm mf2},\ {\rm mf2}))
}{36\ \pi^2}\hfil\\
}{
This is the transversal part of a photon self energy diagram 
with a fermion loop.

$i e^2/( (2 \pi)^4 \, (1-D))$

$ \int d^4 q \, [q^2 - m_f^2]^{-1} [(q-k)^2 -m_f^2]^{-1} $

${\rm tr}[\, (m_f + \bqs - \ks) \, \gamma^{\nu}\, (\bqs + m_f)\, \gamma^{\nu}\,]$ 

$ = $

$-[ e^2 ( k^2 + 6 m_f^2 B_0(0,m_f^2,m_f^2) - $

$- 3 ( k^2 + 2 m_f^2) B_0(k^2, m_f^2, m_f^2) )]/(36 \pi^2)$
}
\enom
Note that in this example, where the dimension is entered explicitly as a 
parameter ($D$), the option \mb{Dimension} of \mb{OneLoop} 
must also be set to $D$ (this is the default). 

\subsection{Generic Diagrams for
${\rm \mb{W}} \rightarrow {\rm \mb{f}}_i \bar{\mb{f}}'_j$ with  OneLoop}
\label{generic}

As an example for calculating triangle diagrams the result 
for two generic one-loop diagrams of the 
decay W $\rightarrow {\rm f}_i \bar{{\rm f}'_j}$ for massless fermions
given in \cite{ansgar} 
is verified with \fc. 

For the two diagrams different approaches are taken. 
In the first one \fc introduces standard matrix elements 
for the part of the diagram containing polarization 
dependencies.
In the other approach the set of standard matrix elements is defined 
by the user before \fc calculates the diagrams.
The last possibility is usually preferable, since the choices of \fc
for the standard matrix elements may have physical significance only 
by accident.

\begin{figure}[H]
\begin{center}
%\special{psfile=wff.ps hoffset=60 voffset=-350 hscale=75 vscale=75}
\scalebox{0.4}{\includegraphics[60,470][400,600]{wff}}
\caption{Two generic diagrams for the decay of W $\rightarrow {\rm f}_i \bar{{\rm f}'_j}$, generated by \fa.}
\end{center}
\end{figure}

\beom
%\dtog{{SetOptions[OneLoop,\ Factoring\ $\Rule$\ True];\\
%}}{}{
%This factors the result.
%}
\dtog{{gc[i\_]\ :=\ g[i,\ "-"]\ DiracMatrix[7]\ +\ \\
g[i,\ "+"]\ DiracMatrix[6];\\
ScalarProduct[p1,\ p1]\ =\ 0;\\
ScalarProduct[p2,\ p2]\ =\ 0;\\
ScalarProduct[p1,\ p2]\ =\ k2/2;\\
MakeBoxes[g[i\_,\ j\_],\ TraditionalForm]\ :=\ SubsuperscriptBox[g,\ i,\ j];
}}{}{
This defines a function for abbreviation purposes:
$g^{c}_i=g_i^{-}\omega_{-} + g_i^{+} \omega_{+}$.

Set the $p_i$ on-shell and $(p_1\cdot p_2)=k^2/2$,
where $k$ denotes the momentum of the W.
}
\domtog{
wff1\ =\ OneLoop[\ q,\ I/(2\ Pi)\phat 4\ FeynAmpDenominator[\\
PropagatorDenominator[q,\ m],\\
PropagatorDenominator[q\ +\ p1],\\
PropagatorDenominator[q\ -\ p2]]\ *\ \\
Spinor[p1]\ .\ DiracMatrix[nu]\ .\ gc[1]\ .\ \\
DiracSlash[q\ +\ p1]\ .\ \\
DiracSlash[Polarization[k]]\ .\\
gc[3]\ .\ DiracSlash[q\ -\ p2]\ .\\
DiracMatrix[nu]\ .\ gc[2]\ .\\
Spinor[p2]\ \ ]\ /.\ (m\phat 2)\ $\Rule$\ m2\\
}{
-\Frac{1}{16\multsp {{\pi }^2}}$
    \big((4\multsp {B_0}(0,0,\Mvariable{m2})-
 2\multsp {B_0}(\Mvariable{k2},0,0)-\\
   2\multsp \Mvariable{k2}\multsp 
    {C_0} ( 0 ,\ 0 ,
      \Mvariable{k2} ,\ 0 ,\ 
     \Mvariable{m2} ,\ 0 )- 2\multsp 
    \Mvariable{m2}\multsp {C_0} ( 0 ,\ 0 ,\ \Mvariable{k2} ,\ 
     0 ,\ \Mvariable{m2} ,\ 0
      )- \\
    4\multsp \Muserfunction{PaVe}(
       0,0,\{0,\Mvariable{k2},0\},\{\Mvariable{m2},0,0\})-1)\multsp\\
 \big(
   g_{1}^{+}\multsp g_{2}^{+}\multsp g_{3}^{+}\multsp 
     \LeftDoubleBracketingBar 
      \varphi  ( \Mvariable{p1} )\ .\ 
       (\gamma  \cdot  
         \varepsilon  ( k ))\ .\ {{\gamma }^6}\ . \
       \varphi  ( \Mvariable{p2} )
       \RightDoubleBracketingBar + \\
 g_{1}^{-}\multsp g_{2}^{-}\multsp 
       g_{3}^{-}\multsp \LeftDoubleBracketingBar 
        \varphi  ( \Mvariable{p1} )\ .\ 
         (\gamma  \cdot  
           \varepsilon  ( k ))\ .\ 
         {{\gamma }^7}\ .\ \varphi  ( \Mvariable{p2}
           )\RightDoubleBracketingBar \big)\big)$
}{
The analytical expression for the generic diagram is:
\\
\\
$\delta {\mathcal m}_1 = i (2 \pi)^{-4}\, \int\, 
(2\pi\mu)^{4-D}\, d^{D}q$

$[(q^2-m^2)\,(q+p_1)^2\,(q-p_2)^2]^{-1}$

$\overline{u}(p_1) \, \gamma^{\nu}\,(g_1^{-} \omega_{-} + g_1^{+} \omega_{+}) 
\,( \bqs + \bps)$ 

$\es (g_3^{-} \omega_{-} + g_3^{+} \omega_{+}) \, 
(\qs - \ps_2 ) \, \gamma^{\nu}\,(g_2^{-} \omega_{-} + g_2^{+} \omega_{+}) \,
v(p_2)$
\\
\\
Translated into the usual notation the result reads:
\\
\\
$( 1 - 2 B_0(k^2, 0,0) + 2 k^2 C_0(0, 0, k^2, 0,m^2,0) +
2 k^2\, C_1(k^2,0,0,0,0,m^2) + 4 C_{00}(k^2,0,0,0,0,m^2) \\
(\, g_1^{+}\, g_2^{+}\, g_3^{+} 
\,\overline{u}(p_1) \,\es\,\omega_{+} \, v(p_2)
 + \,g_1^{-}\, g_2^{-}\, g_3^{-} 
\overline{u}(p_1) \,\es\,\omega_{-} \, v(p_2)))/(16 \pi^2)$ 
\\
\\
The remaining Dirac structure \\ is wrapped with the head \\
\mb{StandardMatrixElement}, which is displayed like
$\LeftDoubleBracketingBar\cdots\RightDoubleBracketingBar$.
}
\domtog{{wff1a\ =\ PaVeReduce[wff1]\ //\ Simplify\\
}}{
\Frac{1}{16\multsp \Mvariable{k2}\multsp {{\pi }^2}}  \\
$\big(
   \big(-2\multsp (2\multsp \Mvariable{k2}+\Mvariable{m2})\multsp 
      {B_0}(0,0,\Mvariable{m2})+
     (3\multsp \Mvariable{k2}+2\multsp \Mvariable{m2})\multsp 
      {B_0}(\Mvariable{k2}, 0, 0)+
     2\multsp \big({C_0}(\Mvariable{k2},
          0, 0, 0, 0, \Mvariable{m2}
          )\multsp {{(\Mvariable{k2}+\Mvariable{m2})}^2}+
        \Mvariable{k2}\big)\big)\multsp   \\
\big(
   g(1,+)\multsp g(2,+)\multsp g(3,+)\multsp 
     \LeftDoubleBracketingBar 
      \varphi (\Mvariable{p1})\ .\ 
       (\gamma \cdot 
         \varepsilon (k))\ .\ {{\gamma }^6}\ .\ 
       \varphi (\Mvariable{p2})
       \RightDoubleBracketingBar +  \\
g(1,-)\multsp g(2,-)\multsp g(3,-)
       \multsp \LeftDoubleBracketingBar 
        \varphi (\Mvariable{p1})\ .\ 
         (\gamma \cdot 
           \varepsilon (k))\ .\ 
         {{\gamma }^7}\ .\ \varphi (\Mvariable{p2}
          )\RightDoubleBracketingBar \big)\big)
$
}{
This reduces the result to scalar integrals.
}
\domtog{{var\ =\ Select[Variables[wff1a],\ (Head[\#]===StandardMatrixElement)\&]\\
}}{$\{\LeftDoubleBracketingBar 
      \varphi (\Mvariable{p1})\ .\ 
       (\gamma \cdot 
         \varepsilon (k))\ .\ {{\gamma }^6}\ .\ 
       \varphi (\Mvariable{p2})
       \RightDoubleBracketingBar,\ \\
\ \\
\ \ \LeftDoubleBracketingBar 
        \varphi (\Mvariable{p1})\ .\ 
         (\gamma \cdot 
           \varepsilon (k))\ .\ 
         {{\gamma }^7}\ .\ \varphi (\Mvariable{p2}
          )\RightDoubleBracketingBar\}$
}{
With this command you can \\
extract the standard matrix elements.
}
\dtog{{Set\ @@\ \{var,\ \{ma[1],\ ma[2]\}\ \}\\
}}{}{
Here the \\
\mb{StandardMatrixElement}s are set to some abbreviations.
}
\dtog{{Write2["wff1a.for",\ vert\ =\ wff1a\ /.\\
g[i\_,\ "+"]\ $\Rule$\ gp[i]\ /.\\
g[i\_,\ "-"]\ $\Rule$\ gm[i],\ FormatType\ $\Rule$\ FortranForm];\\
}}{}{
In this way you can generate a Fortran file.

With replacements you can adapt the result to your other 
Fortran code.
}
\dtog{!!wff1a.for\\
\\
\scriptsize\tt
vert = (((3*k2 + 2*m2)*B0(k2,Null,Null) - \\
\&      2*(2*k2 + m2)*B0(Null,m2,Null) + \\
\&      2*(k2 + (k2 + m2)**2*\\
\&          C0(k2,Null,Null,Null,Null,m2)))*\\
\&    (gp(1)*gp(2)*gp(3)*ma(1)+gm(1)*gm(2)*gm(3)*ma(2)))\\
\&   /(16D1*k2*Pi**2)
}{}{
Show the content of the file.
}
\dtog{DeleteFile["wff1a.for"];\\
Clear[gc, g, wff1, wff1a, ma];}{}{Clean up.}
\enom

\otabtwo{
\mbs{StandardMatrixElement[ {\sl expr}]} & a standard matrix element \cr
\hspace*{-18pt}\mbs{SetStandardMatrixElements[\{\ \{{\sl sm1}\ $\Rule$\ {\sl abb1}\},\ \{{\sl sm2}\ $\Rule$ \ {\sl abb2}\},\ ...\}]}&
set abbreviations for standard matrix elements \cr
\hspace*{-18pt}\mbs{SetStandardMatrixElements[\{\ \{{\sl sm1}\ $\Rule$\ {\sl abb1}\},\ \{{\sl sm2}\ $\Rule$ \ {\sl abb2}\},\ ...\}}, 
$k_2 \Rule p_1+p_2-k_1$\mb{]}& set abbreviations  for standard matrix elements by using 
energy momentum conservation 
} {A head for identifying standard matrix elements; {\sl sm1}, {\sl sm2} are the standard
matrix elements, {\sl abb1}, {\sl abb2} the abbreviations.}

The function \mb{SetStandardMatrixElements} introduces 
\mb{StandardMatrixElement[{\sl abb1}\\]} for \mb{{\sl sm1}}.
The abbreviations \mb{{\sl abb1}}, \mb{{\sl abb2}}, $\ldots$ may be numbers or
strings.

For calculating the generic triangle diagram with a non-abelian gauge coupling
the standard matrix elements are set ahead using \mb{SetStandardMatrixElements}.

\beom
\dtog{{r\ =\ DiracMatrix[6];\ l\ =\ DiracMatrix[7];\\
ScalarProduct[p1,\ p1]\ =\ ScalarProduct[p2,\ p2]\ =\ 0;\\
ScalarProduct[p1,\ p2]\ =\ k2/2\ ;\\
SetOptions[\ OneLoop,\ \\
Factoring\ $\Rule$\ True,\ FormatType\ $\Rule$\ FortranForm,\\
ReduceToScalars\ $\Rule$\ True,\ WriteOut $\Rule$ True,\\
FinalSubstitutions\ $\Rule$\ \{g[i\_,\ "+"]\ $\Rule$\ gp[i],\ 
g[i\_,\ "-"]\ $\Rule$\ gm[i],\\
StandardMatrixElement\ $\Rule$ \ ma\}\ ];\\
mt\ =\ MetricTensor;\ fv\ =\ FourVector;\\
feynden[x:\{\_,\ \_\}..]\ :=\ FeynAmpDenominator\ @@\ \\
Map[Apply[PropagatorDenominator,\ \#]\&,\ \{x\}];\\
}}{}{
The option \mb{ReduceToScalars} is set to \mb{True};
this will produce directly a result  in 
terms of  $B_0$ and $C_0$.

The other definitions are 
convenient abbreviations:
\mb{r} for the right-handed projection operator 
 $\gamma_6$, \mb{l} for the left-handed projection operator 
$\gamma_7$, short mnemonic functions 
like \mb{mt}, \mb{fv} and \mb{feynden} 
stand for  metric tensors, four-vectors and 
denominators of propagators.
}
\dtog{{SetStandardMatrixElements[\ \\
\ \{\ (\ \ Spinor[p1]\ .\ DiracSlash[Polarization[k]].\ 
r\ .\ Spinor[p2]\ )\ $\Rule$\ \{1\},\\
(\ \ Spinor[p1]\ .\ DiracSlash[Polarization[k]].\ 
l\ .\ Spinor[p2]\ )\ $\Rule$\ \{2\}\}];\\
}}{}{
This sets the standard matrix elements:

${\mathcal M}_1^{+} = \overline{u}(p_1) \, \es_1\, \omega_{+}\,v(p_2)$

${\mathcal M}_1^{-} = \overline{u}(p_1) \, \es_1\, \omega_{-}\,v(p_2)$
}
\domtog{
OneLoop[q,\ I/(2\ Pi)\phat 4\ *\ \\
feynden[\{q,\ 0\},\ \{q\ +\ p1,\ m1\},\ \{q\ -\ p2,\ m2\}]\ *\\
Spinor[p1]\ .\ DiracMatrix[nu]\ .\ \\
(g[1,\ "-"]\ l\ +\ g[1,\ "+"]\ r)\ .\ \\
DiracSlash[-q]\ .\ DiracMatrix[ro]\ .\\
(g[2,\ "-"]\ l\ +\ g[2,\ "+"]\ r) . Spinor[p2]\ *\ \\
g3\ (\ mt[ro,\ mu]\ fv[p1\ +\ 2\ p2\ -\ q,\ nu]\ -\ \\
mt[mu,\ nu]\ fv[2\ p1\ +\ p2\ +\ q,\ ro]\ +\ \\
mt[nu,\ ro]\ fv[2\ q\ +\ p1\ -\ p2,\ mu]\ )\ *\\
PolarizationVector[k,\ mu]\\
]\ /.\ (m1\phat 2)\ $\Rule$\ m12\ /.\ (m2\phat 2)\ $\Rule$\ m22\\
}{
-\Frac{1}{(16\ {\rm k2}\ \pi^2)} \\
$({\rm g3}\ ((2\ {\rm k2}\ +\ {\rm m12})\ B_0(0,\ 0,\ {\rm m12})\ + \\ 
(2\ {\rm k2}\ +\ {\rm m22})\ B_0(0,\ 0,\ {\rm m22})\ - \\ 
({\rm k2}\ +\ {\rm m12}\ +\ {\rm m22})\ B_0({\rm k2},\ {\rm m12},\ {\rm m22})\ +\ 
2\ ({\rm k2}\ {\rm m12}\ +\ {\rm m22}\ {\rm m12}\ +\ {\rm k2}\ {\rm m22})\ 
C_0({\rm k2},\ 0,\ 0,\ {\rm m12},\ {\rm m22},\ 0))\\
({\rm gp}(1)\ {\rm gp})(2)\ {\rm ma}(1)\ +\ {\rm gm}(1)\ {\rm gm}(2)\ {\rm ma}(2))
)$
}{
Here is the second generic diagram.

Note that in the result \mb{StandardMatrixElement}
is replaced by \mb{ma}, as specified in the option
\mb{FinalSubstitutions} of \mb{OneLoop} above.
}
\domtog{{!!"wff2.for"\\
}}{\scriptsize\tt
wff2 = -(g3*(-((k2 + m1**2 + m2**2)*B0(k2,m1**2,m2**2)) + \\
\&       (2*k2 + m1**2)*B0(Null,m1**2,Null) + \\
\&       (2*k2 + m2**2)*B0(Null,m2**2,Null) + \\
\&       2*(k2*m1**2 + k2*m2**2 + m1**2*m2**2)*\\
\&       C0(k2,Null,Null,m1**2,m2**2,Null))*\\
\&       (gp(1)*gp(2)*ma(1) + gm(1)*gm(2)*ma(2)))/\\
\&       (16D1*k2*Pi**2)

}{
As specified above in the options for \mb{OneLoop},
Fortran output has been written to a file.
}
%\domtog{{OneLoopResult[wff2]\\
%}}{\ -(g3\ ((2\ k2\ +\ \superscript{M1}{2})\ B0[0,\ 0,\ \superscript{M1}{2}]\ +\ (2\ k2\ +\ %\superscript{M2}{2})\ B0[0,\ 0,\ \superscript{M2}{2}]\ -\ (k2\ +\ \superscript{M1}{2} +\ %\superscript{M2}{2})\ B0[k2,\ \superscript{M1}{2},\ \superscript{M2}{2}]\ +\ 2\ (k2\ %\superscript{M1}{2} +\ k2\ \superscript{M2}{2} +\ \superscript{M1}{2} \superscript{M2}{2})\ %C0[0,\ 0,\ k2,\ M1\ ,\ 0,\ M2\ ])\ (gp[1]\ gp[2]\ mat[1]\ +\ gm[1]\ gm[2]\ mat[2]))\ /\ (16\ k2\ %\superscript{Pi}{2})\hfil\\
%}{
%The result is also automatically \\
%assigned to \\
%\mb{OneLoopResult[{\sl name}]}.
%}
\dtog{DeleteFile["wff2.for"];\\
DeleteFile\ /@\ FileNames["PaVe*"];\\
Clear[r,\ l,\ mt,\ fv,\ feynden,\ wff2];}{}{Clean up.}
\enom

%\otabtwo{
%\mbs{OneLoopResult[{\sl name}]} & is set to the result of \mb{OneLoop[{\sl name},\ ...]}
%}{\mb{OneLoopResult[{\sl name}]} gets values as a side effect of \mb{OneLoop}.}

\subsection{The Options of OneLoop}
\label{oneopt}
Several options of \mb{OneLoop} have already been introduced in the previous
section.
Here the full list of available options is given. 
The example in section \ref{eezh} shows the use of some options.

In the automatic calculation of one-loop amplitudes it does not matter in which order the 
arguments of \mb{FeynAmpDenominator} are given. Therefore the default setting of \mb{DenomatorOrder}
is \mb{True}. In case you want to verify a result obtained by hand calculation, you can set this 
option to \mb{False}, which will preserve the order of the propagators as entered.
If you want to include the dimension $D$ explicitly in the input, as in the example
in section \ref{self}, you have to set \mb{Dimension\ $\Rule$\ D}.

With the default setting of \mb{Dimension} you can enter four-dimensional objects to 
\mb{OneLoop}, which are automatically extended to $D$ dimensions inside \mb{OneLoop}.
In case you want to calculate a finite amplitude, you can set \mb{Dimension\ $\Rule$\ 4}.

%The option \mb{FinalSubstitutions} indicates substitutions that are done at the very end 
%of the calculation, which may be useful to adapt the output to your Fortran program.

The \mb{Factoring} option should be used only for relatively small problems, since it may 
be very time consuming to factor the result. Unless the result of \mb{OneLoop} is 
very short, only 
the coefficients of \mb{StandardMatrixElement} are factored.

\mb{FormatType} takes \mb{InputForm}, \mb{FortranForm}, \mb{MacsymaForm} or \mb{MapleForm}
as settings. If the option \mb{WriteOut} is set to \mb{True}, the result is written out 
into a file using \mb{Write2} with the setting of \mb{FormatType}.

Replacements are  
done with \mb{InitialSubstitutions} and \mb{FinalSubstitutions}.
Especially energy momentum conservation should be included, e.g., 
\mb{InitialSubstitutions\ $\Rule$\ \{k2\ $\Rule$\ -\ k1\ \ +\ p1\ +\ p3\}}.
Note that the rules listed in \mb{FinalSubstitutions} are not applied as one list of rules, 
but sequentially in a loop.

For more tuning, the option \mb{IntermediateSubstitutions} can be used. Usually this should not be necessary. These rules are applied somewhere in the middle of the calculation.

If \mb{IsolateNames} is set to \mb{c}, for example, the result will be given as
a \mb{c[i]} in \mb{HoldForm}. See \mb{Isolate} for more information.
The setting of \mb{Mandelstam} may be, e.g., 
\mb{Mandelstam\ $\Rule$\ \{{\sl s},\ {\sl t},\ {\sl u},\ {\sl m1}\phat 2\ +\ {\sl m2}\phat 2\ +\ {\sl m3}\phat 2\ +\ {\sl m4}\phat 2\}}, where  $s + t + u = m_1^2 + m_2^2 + m_3^2 + m_4^2$.

The option \mb{ReduceToScalars} should not be set to \mb{True} when calculating several complicated diagrams involving $D_{\mu \nu \rho}$ or $D_{\mu \nu \rho \sigma}$. 
Depending on the computer you are using  it may nevertheless work, but it is usually better 
to use \mb{OneLoopSum} with the appropriate options. Note that depending on the setting of the 
option \mb{BReduce} also two-point coefficient functions may remain in the result.

For processes with light external fermions it is best not to neglect the fermion masses
everywhere, but to keep them in the arguments of the scalar Passarino-Veltman functions.
This set of masses should be supplied as a list to the option \mb{SmallVariables}, see section \ref{eezh}. 

If \mb{WriteOut} is set to \mb{True}, the result is written to a file composed of the first
argument of \mb{OneLoop}, i.e., the $name$. In which language, i.e., 
\mma, Fortran, Macsyma or Maple the result is written, depends on the setting of the option \mb{FormatType}.
You may also set \mb{WriteOut} to a string, which denotes the directory 
in which to the result (actually this string is simply prepended to the file names).

\otabthree{
{\sl option name} & {\sl default value} &\cr
\hhline
\mb{Apart2} & \mb{True} & use \mb{Apart2} to partial fraction denominators \cr
\mb{CancelQP} & \mb{True} & cancel $q\cdot p$ and $q^2$ \cr
\mb{DenominatorOrder} & \mb{False}  &  
order the arguments of \mb{FeynAmpDenominator} 
canonically \cr
\mb{Dimension} & \mb{D} & number of space-time dimensions\cr
\mb{Factoring} & \mb{False}  &  factor the result \cr
\mb{FinalSubstitutions} & \mb{\{\}} & substitutions done at the end of the
calculation \cr
\mb{FormatType} & \mb{InputForm} & how to write out the result file\cr
\mb{InitialSubstitutions} & \mb{\{\}} & substitutions done at the beginning of the calculation, e.g. energy-momentum conservation \cr
\mb{IntermediateSubstitutions} & \hspace*{20pt} \mb{\{\}} & substitutions done at an intermediate stage of the
calculation \cr
\mb{IsolateNames}          & \mb{False} & use \mb{Isolate} on the result \cr
\mb{Mandelstam} & \mb{\{\}} &  indicate the Mandelstam relation \cr
\mb{OneLoopSimplify} & \mb{False} & use \mb{OneLoopSimplify} at the beginning of the calculation \cr
\mb{Prefactor} & \mb{1}   &  extra prefactor of the amplitude \cr
\mb{ReduceGamma}   &  \mb{False}  & insert for $\gamma_6$ and $\gamma_7$ their definitions \cr
\mb{ReduceToScalars}   &  \mb{False}  & reduce to $B_{0}, C_{0},D_{0}$ \cr
\mb{SmallVariables} & \mb{\{\}} &  a list of masses, which will get wrapped with the head \mb{SmallVariable} \cr
\mb{WriteOut} &  \mb{False} &  write out a result file carrying the name of the optional first argument of \mb{OneLoop} \cr
\mb{WriteOutPaVe} &  \mb{False} &  store \mb{PaVe}s in files \cr
\mb{Sum} &  \mb{True} & compatibility with \fa; sum terms multiplied with \fa' \mb{SumOver} \cr
}{Options of \mb{OneLoop}.}

\subsection{OneLoopSum and Its Options}

To sum a list of amplitudes two different methods are provided by
\mb{OneLoopSum}. Either the provided list of amplitudes is calculated and 
subsequently summed, or the summation is done partially before the calculation.
This can be specified with the option \mb{CombineGraphs}.

\otabtwo{
\mbs{OneLoopSum[\{FeynAmp[ GraphName[...,\ {\sl N1}],\ {\sl q},\ {\sl amp1}], 
FeynAmp[GraphName[...,\ {\sl N2}],\ {\sl q},\ {\sl amp2}],\ ...\}]} & calculate a list of amplitudes \cr
\mbs{OneLoopSum[{\sl expr}]} & sum already calculated amplitudes \cr
}{A function for summing one-loop amplitudes.
%\mb{FeynAmpList}, \mb{FeynAmp} and \mb{GraphName} are heads of \fa.
}

The input of \mb{OneLoopSum} is adapted to the output of \fa \footnote{Actually to version 1 of \fa, but later versions provide a function translating to version 1 syntax (\mb{ToFA1Conventions}). The examples given here all use \fa version 3.} .
After saving a list of Feynman diagrams (that is, unintegrated amplitudes)
created with \fa\ using the function \mb{CreateFeynAmp}, you can start a new \mma session 
\footnote{It is not possible to load \fc and \fa\ 
simultaneously into one \mma session because some functions of \fa and \fc have the same name but are in different contexts (name spaces). A more sophisticated approach is provided by the optional subpackage \fphi, which patches \fa slightly, allowing the two packages to be loaded simultaneously.},
load \fc, get the amplitudes, calculate the amplitude with \mb{OneLoopSum} and finally 
save the result e.g. as a Fortran file.
%\footnote{Sometimes you will get an error message when loading a file.
%This is a bug in the \mma saving routine and may be fixed by editing the 
%file and enclosing the whole expression in two round brackets $( ... )$.
%Do not put a ";" after the last round bracket.}

Below follows a sequence of commands to execute in order to generate a set of amplitudes from the insertions on the "particles" level and save it in a format understood be \fc.

\mcode{CreateFeynAmp[{\sl ins}] // PickLevel[Particles] // ToFA1Conventions >> {\sl filename}}

After quitting the kernel and loading \fc, the amplitudes can be loaded by

\mcode{{\sl amps}\ =\ << {\sl filename}}

To actually use the Fortran file, obviously the constants and functions used, like masses and scalar integrals, have to be defined. This is discussed in section \ref{process}.

Instead of supplying a list of not yet calculated amplitudes you can also
give the  sum of already calculated ones as argument ({\sl expr}) to \mb{OneLoopSum}.

The output of \mb{OneLoopSum} is typically given as a short expression wrapped in \mb{HoldForm}. In order to get the full expression, the function \mb{FRH} can be applied.

\otabtwo{
\mbs{FRH[{\sl expr}]} & removes all \mb{HoldForm} and \mb{Hold} in {\sl expr}
}{A utility function.}

\otabthree{
{\sl option name} & {\sl default value} &\cr
\hhline
\mb{CombineGraphs} & \mb{\{\}} & combine amplitudes \cr
%ahead of calculating \cr
\mb{Dimension}  & \mb{True} & number of space-time dimensions \cr
\mb{ExtraVariables}  & \mb{\{\}} & list of variables which are bracketed out in the result 
like \mb{B0}, \mb{C0}, \mb{D0} and  \mb{PaVe} \cr
\mb{FinalFunction}  & \mb{Identity} & function applied to the result \cr
\mb{FinalSubstitutions}  & \mb{\{\}} & substitutions done at the end of the calculation \cr
\mb{FormatType}  & \mb{InputForm} & format used when saving results \cr
\mb{InitialSubstitutions}  & \mb{\{\}} & substitutions done at the beginning of the calculation \cr
\mb{IntermediateSubstitutions}  & \hspace*{20pt} \mb{\{\}} & substitutions done at an intermediate stage in the calculation \cr
\mb{IsolateNames}  & \mb{KK} & \mb{Isolate} the result \cr
\mb{Mandelstam}  & \mb{\{\}} & use the Mandelstam relation \cr
\mb{Prefactor} & \mb{1} & multiply the result by a pre-factor \cr
\mb{ReduceToScalars} &\mb{True} & reduce to scalar integrals \cr
\mb{SelectGraphs} & \mb{All} & which graphs to select \cr
\mb{WriteOutPaVe} & \mb{False} & write out the reduced \mb{PaVe}
}{Options of \mb{OneLoopSum}.}

With the default options \mb{OneLoopSum} calculates each amplitude 
separately by 
substituting \mb{OneLoop} for \mb{FeynAmp}. Then each single \mb{PaVe} is reduced 
to scalar integrals. The hard final part consists in the simplification of 
the rational coefficients of the scalar integrals. 
This may involve thousands of factorizations
and can therefore take hours of CPU time. But the algebraic simplifications achieved 
by putting all coefficients of the scalar integrals over a common denominator and 
to factor them, possibly cancelling factors and reducing the singularity 
structure, may be very significant.
These calculations may need quite a lot of RAM space, therefore the options
of \mb{OneLoopSum} allow you to split up the task of summing lots of diagrams.

First you can select a certain subclass of diagrams with the option \mb{SelectGraphs}.
You may set, e.g., \mb{SelectGraphs\ $\Rule$\ \{1,\ 2,\ 5,\ 8\}}, which selects the 
amplitudes at positions 1, 2, 5 and 8 of the argument list of \mb{OneLoopSum}.
The setting \mb{SelectGraphs\ $\Rule$\ \{1,\ 2,\ 5,\ 8,\ \{10,\ 40\}\}} also includes the range of all amplitudes from position 10 to 40.

With the option \mb{CombineGraphs} a possibility is given to sum the graphs before 
calculation. This is especially useful for combining a graph with its crossed counterpart.
In general it makes sense to combine all graphs with the same propagators before 
calculation, but for very big sums this may reduce the performance considerably.
The possible settings for \mb{CombineGraphs} are the same as for \mb{SelectGraphs}.
If you use the \fa\ syntax for the first argument of \mb{FeynAmp},   
i.e. \mb{GraphName[...,\ N1]}, the last arguments of \mb{GraphName} for 
combined graphs are concatenated and a new \mb{GraphName} for the summed amplitude
is created.

By setting the option \mb{WriteOutPaVe} you can save 
the result of the reduction of each \mb{PaVe} to a file for later use.
The names of the corresponding files are generated automatically.
In case you use \mb{OneLoopSum} several times it recognizes previously saved
reductions and loads these results automatically. This may save a considerable amount of time. 
Instead of setting the option \mb{WriteOutPaVe} to an empty string 
(which means that the files are written in the current directory), you can 
specify another directory (a string prepended to the file names).

Note that these options together with the possibility of 
using \mb{OneLoopSum} on already calculated graphs
gives you a lot freedom to split up the calculation, 
which may be necessary in order to avoid memory overflow.
It can also be a good idea to set \mb{\$VeryVerbose} to 1 or 2 for monitoring the calculation.

The option \mb{Prefactor} may be used to extract global factors.
You can, e.g., do \mb{SetOptions[OneLoop,\ Prefactor\ $\Rule$\ (2\ SW\phat 2)},
which causes each single amplitude to be multiplied by $2 s_{\rm W}^2$, and 
\mb{SetOptions[OneLoopSum,\ Prefactor\ $\Rule$\ 1/(2\ SW\phat 2)}, which causes the result of 
\mb{OneLoopSum} to have $1/(2 s_{\rm W}^2)$ as a global factor.

\subsection{Box Graphs of ${\rm e}^+ {\rm e}^- \rightarrow {\rm ZH}$}
\label{eezh}

In this section it is shown how to calculate a sum of amplitudes with \mb{OneLoopSum}. The input consists of a one page program with process-dependent definitions. This program reads in a file with unmodified output of \fa for the amplitudes. The Fortran file produced is obtained without any interactive action.

The six standard matrix elements are:

\begin{displaymath}
\begin{array}{rcl}
{\mathcal M}_0^1 &=& \overline{v}(p_1) \, \es \, \omega_+ \, u(p_2)\\
{\mathcal M}_0^2 &=& \overline{v}(p_1) \, \es \, \omega_- \, u(p_2)\\
{\mathcal M}_1^1 &=& \overline{v}(p_1) \, \ks_1 \, \omega_+ \, u(p_2) \, \epsilon \, p_1\\
{\mathcal M}_1^2 &=& \overline{v}(p_1) \, \ks_1 \, \omega_- \, u(p_2) \, \epsilon \, p_1\\
{\mathcal M}_2^1 &=& \overline{v}(p_1) \, \ks_1 \, \omega_+ \, u(p_2) \, \epsilon \, p_2\\
{\mathcal M}_2^2 &=& \overline{v}(p_1) \, \ks_1 \, \omega_- \, u(p_2) \, \epsilon \, p_2
\end{array}
\end{displaymath}

%\begin{figure}[H]
%\begin{center}
%\scalebox{0.6}{\includegraphics[60,300][500,640]{eezh}}
%\caption{The six box diagrams of ${\rm e}^+ {\rm e}^- \rightarrow {\rm ZH}$, generated by \fa. $\varphi$ denotes the
%unphysical charged Higgs.}
%\end{center}
%\end{figure}

\vspace*{-20pt}

\begin{figure}[H]
\begin{center}
\unitlength=1bp%

\begin{feynartspicture}(216,288)(3,3)

\FADiagram{}
\FAProp(0.,15.)(6.5,13.5)(0.,){/Straight}{1}
\FALabel(3.59853,15.2803)[b]{e}
\FAProp(0.,5.)(6.5,6.5)(0.,){/Straight}{-1}
\FALabel(3.59853,4.71969)[t]{e}
\FAProp(20.,15.)(13.5,13.5)(0.,){/Sine}{0}
\FALabel(16.4015,15.2803)[b]{Z}
\FAProp(20.,5.)(13.5,6.5)(0.,){/ScalarDash}{0}
\FALabel(16.4577,4.96329)[t]{H}
\FAProp(6.5,13.5)(6.5,6.5)(0.,){/Straight}{1}
\FALabel(5.43,10.)[r]{$\nu_{\rm e}$}
\FAProp(6.5,13.5)(13.5,13.5)(0.,){/Sine}{1}
\FALabel(10.,14.57)[b]{W}
\FAProp(6.5,6.5)(13.5,6.5)(0.,){/Sine}{-1}
\FALabel(10.,5.43)[t]{W}
\FAProp(13.5,13.5)(13.5,6.5)(0.,){/ScalarDash}{1}
\FALabel(14.57,10.)[l]{G}
\FAVert(6.5,13.5){0}
\FAVert(6.5,6.5){0}
\FAVert(13.5,13.5){0}
\FAVert(13.5,6.5){0}

\FADiagram{}
\FAProp(0.,15.)(6.5,13.5)(0.,){/Straight}{1}
\FALabel(3.59853,15.2803)[b]{e}
\FAProp(0.,5.)(6.5,6.5)(0.,){/Straight}{-1}
\FALabel(3.59853,4.71969)[t]{e}
\FAProp(20.,15.)(13.5,13.5)(0.,){/Sine}{0}
\FALabel(16.4015,15.2803)[b]{Z}
\FAProp(20.,5.)(13.5,6.5)(0.,){/ScalarDash}{0}
\FALabel(16.4577,4.96329)[t]{H}
\FAProp(6.5,13.5)(6.5,6.5)(0.,){/Straight}{1}
\FALabel(5.43,10.)[r]{$\nu_{\rm e}$}
\FAProp(6.5,13.5)(13.5,13.5)(0.,){/Sine}{1}
\FALabel(10.,14.57)[b]{W}
\FAProp(6.5,6.5)(13.5,6.5)(0.,){/Sine}{-1}
\FALabel(10.,5.43)[t]{W}
\FAProp(13.5,13.5)(13.5,6.5)(0.,){/Sine}{1}
\FALabel(14.57,10.)[l]{W}
\FAVert(6.5,13.5){0}
\FAVert(6.5,6.5){0}
\FAVert(13.5,13.5){0}
\FAVert(13.5,6.5){0}

\FADiagram{}
\FAProp(0.,15.)(6.5,13.5)(0.,){/Straight}{1}
\FALabel(3.59853,15.2803)[b]{e}
\FAProp(0.,5.)(6.5,6.5)(0.,){/Straight}{-1}
\FALabel(3.59853,4.71969)[t]{e}
\FAProp(20.,15.)(13.5,6.5)(0.,){/Sine}{0}
\FALabel(17.9814,13.8219)[br]{Z}
\FAProp(20.,5.)(13.5,13.5)(0.,){/ScalarDash}{0}
\FALabel(18.03,6.58)[tr]{H}
\FAProp(6.5,13.5)(6.5,6.5)(0.,){/Straight}{1}
\FALabel(5.43,10.)[r]{$\nu_{\rm e}$}
\FAProp(6.5,13.5)(13.5,13.5)(0.,){/Sine}{1}
\FALabel(10.,14.57)[b]{W}
\FAProp(6.5,6.5)(13.5,6.5)(0.,){/Sine}{-1}
\FALabel(10.,5.43)[t]{W}
\FAProp(13.5,6.5)(13.5,13.5)(0.,){/ScalarDash}{-1}
\FALabel(12.43,10.)[r]{G}
\FAVert(6.5,13.5){0}
\FAVert(6.5,6.5){0}
\FAVert(13.5,6.5){0}
\FAVert(13.5,13.5){0}

\FADiagram{}
\FAProp(0.,15.)(6.5,13.5)(0.,){/Straight}{1}
\FALabel(3.59853,15.2803)[b]{e}
\FAProp(0.,5.)(6.5,6.5)(0.,){/Straight}{-1}
\FALabel(3.59853,4.71969)[t]{e}
\FAProp(20.,15.)(13.5,6.5)(0.,){/Sine}{0}
\FALabel(17.9814,13.8219)[br]{Z}
\FAProp(20.,5.)(13.5,13.5)(0.,){/ScalarDash}{0}
\FALabel(18.03,6.58)[tr]{H}
\FAProp(6.5,13.5)(6.5,6.5)(0.,){/Straight}{1}
\FALabel(5.43,10.)[r]{$\nu_{\rm e}$}
\FAProp(6.5,13.5)(13.5,13.5)(0.,){/Sine}{1}
\FALabel(10.,14.57)[b]{W}
\FAProp(6.5,6.5)(13.5,6.5)(0.,){/Sine}{-1}
\FALabel(10.,5.43)[t]{W}
\FAProp(13.5,6.5)(13.5,13.5)(0.,){/Sine}{-1}
\FALabel(12.43,10.)[r]{W}
\FAVert(6.5,13.5){0}
\FAVert(6.5,6.5){0}
\FAVert(13.5,6.5){0}
\FAVert(13.5,13.5){0}

\FADiagram{}
\FAProp(0.,15.)(13.5,13.)(0.,){/Straight}{1}
\FALabel(3.41023,15.5279)[b]{e}
\FAProp(0.,5.)(6.5,6.)(0.,){/Straight}{-1}
\FALabel(3.48569,4.44802)[t]{e}
\FAProp(20.,15.)(6.5,13.)(0.,){/Sine}{0}
\FALabel(16.5898,15.5279)[b]{Z}
\FAProp(20.,5.)(13.5,6.)(0.,){/ScalarDash}{0}
\FALabel(16.5523,4.69512)[t]{H}
\FAProp(13.5,13.)(6.5,13.)(0.,){/Straight}{1}
\FALabel(10.,11.93)[t]{e}
\FAProp(13.5,13.)(13.5,6.)(0.,){/Sine}{0}
\FALabel(14.57,9.5)[l]{Z}
\FAProp(6.5,6.)(6.5,13.)(0.,){/Straight}{-1}
\FALabel(5.43,9.5)[r]{e}
\FAProp(6.5,6.)(13.5,6.)(0.,){/Sine}{0}
\FALabel(10.,4.93)[t]{Z}
\FAVert(13.5,13.){0}
\FAVert(6.5,6.){0}
\FAVert(6.5,13.){0}
\FAVert(13.5,6.){0}

\FADiagram{}
\FAProp(0.,15.)(13.5,13.)(0.,){/Straight}{1}
\FALabel(3.41023,15.5279)[b]{e}
\FAProp(0.,5.)(6.5,6.)(0.,){/Straight}{-1}
\FALabel(3.48569,4.44802)[t]{e}
\FAProp(20.,15.)(6.5,13.)(0.,){/Sine}{0}
\FALabel(16.5898,15.5279)[b]{Z}
\FAProp(20.,5.)(13.5,6.)(0.,){/ScalarDash}{0}
\FALabel(16.5523,4.69512)[t]{H}
\FAProp(13.5,13.)(6.5,13.)(0.,){/Straight}{1}
\FALabel(10.,11.93)[t]{$\nu_{\rm e}$}
\FAProp(13.5,13.)(13.5,6.)(0.,){/Sine}{1}
\FALabel(14.57,9.5)[l]{W}
\FAProp(6.5,6.)(6.5,13.)(0.,){/Straight}{-1}
\FALabel(5.43,9.5)[r]{$\nu_{\rm e}$}
\FAProp(6.5,6.)(13.5,6.)(0.,){/Sine}{-1}
\FALabel(10.,4.93)[t]{W}
\FAVert(13.5,13.){0}
\FAVert(6.5,6.){0}
\FAVert(6.5,13.){0}
\FAVert(13.5,6.){0}
\end{feynartspicture}
\vspace*{-90pt}
\caption{Box diagrams of ${\rm e}^+ {\rm e}^- \rightarrow {\rm ZH}$, generated by \fa. G denotes the unphysical charged Higgs.}
\end{center}
\end{figure}

\begin{figure}[H]
\begin{footnotesize}
\begin{verbatim}

(*Generate the box topologies*)
tops = CreateTopologies[1, 2 -> 2, Adjacencies -> {3}, 
      ExcludeTopologies -> {SelfEnergies, WFCorrections, Tadpoles, 
          Boxes[3]}];

(*Check that the right topologies were generated*)
Paint[tops, ColumnsXRows -> {3, 1}];

(*Insert fields*)
inserttops = 
    InsertFields[tops, {F[2, {1}], -F[2, {1}]} -> {V[2], S[1]}, Model -> "SM",
       GenericModel -> "Lorentz", InsertionLevel -> Particles, 
      ExcludeFieldPoints -> {FieldPoint[F, -F, S]}];

(*Display the graphs*)
graphs = Paint[inserttops, PaintLevel -> {Particles}, AutoEdit -> False, 
      SheetHeader -> False, Numbering -> False, ColumnsXRows -> {3, 2}];

(*Generate amplitude*)
eezhb = CreateFeynAmp[inserttops, AmplitudeLevel -> Particles];

(*Save amplitude in a format understood by FeynCalc*)
PickLevel[Particles][eezhb] // ToFA1Conventions >> "eezhb.amp";

\end{verbatim}
\end{footnotesize}
\begin{tabular*}{0.8\textwidth}{c}\hhline\end{tabular*}
\GrayCaption{For completeness here is the input program for generating boxes of ${\rm e}^+{\rm e}^- \rightarrow  {\rm ZH}$ with \fa.}
\end{figure}

\begin{figure}[H]
\begin{footnotesize}
\begin{verbatim}

(*Define the Mandelstam variables and put momenta on - shell*)
  SetMandelstam[s, t, u, p1, p2, -k1, -k2, SmallVariable[ME], 
    SmallVariable[ME], MZ, MH];

(*Set the option for the ordering of D0's*)
SetOptions[PaVeOrder, PaVeOrderList -> {{s, t}, {s, u}, {t, u}}];

(*Set the options for OneLoop*)
SetOptions[OneLoop, Mandelstam -> {s, t, u, MH^2 + MZ^2}, 
    Prefactor -> 1/ALPHA2, 
    InitialSubstitutions -> {k2 -> p1 + p2 - k1, CW -> MW/MZ, 
        EL -> Sqrt[4 Pi Sqrt[ALPHA2]]}, SmallVariables -> {ME, ME2}];

(*The option for OneLoopSum introduces abbreviations at the end*)
SetOptions[OneLoopSum, Prefactor -> 2 ALP4PI FLUFAC, 
    Mandelstam -> {s, t, u, MH^2 + MZ^2}, 
    FinalSubstitutions -> {SW -> Sqrt[SW2], ME -> Sqrt[ME2], MW -> Sqrt[MW2], 
        MZ -> Sqrt[MZ2], MH -> Sqrt[MH2], 
        ME2^n_ :> ME^(2 n) /; Head[n] =!= Integer, 
        MZ2^n_ :> MZ^(2 n) /; Head[n] =!= Integer, 
        MW2^n_ :> MW^(2 n) /; Head[n] =!= Integer, 
        MH2^n_ :> MH^(2 n) /; Head[n] =!= Integer, 
        SW2^n_ :> SW^(2 n) /; Head[n] =!= Integer, 
        StandardMatrixElement -> MBM}, WriteOutPaVe -> ""];

(*Define the standard matrix elements*)
SetStandardMatrixElements[{Spinor[p1].DiracSlash[
            Conjugate[Polarization[k1]]].ChiralityProjector[+1].Spinor[
            p2] -> {0, 1}, 
      Spinor[p1].DiracSlash[
            Conjugate[Polarization[k1]]].ChiralityProjector[-1].Spinor[
            p2] -> {0, 2}, 
      ScalarProduct[Conjugate[Polarization[k1]], p1]*
          Spinor[p1].DiracSlash[k1].ChiralityProjector[+1].Spinor[p2] -> {1, 
          1}, ScalarProduct[Conjugate[Polarization[k1]], p1]*
          Spinor[p1].DiracSlash[k1].ChiralityProjector[-1].Spinor[p2] -> {1, 
          2}, ScalarProduct[Conjugate[Polarization[k1]], p2]*
          Spinor[p1].DiracSlash[k1].ChiralityProjector[+1].Spinor[p2] -> {2, 
          1}, ScalarProduct[Conjugate[Polarization[k1]], p2]*
          Spinor[p1].DiracSlash[k1].ChiralityProjector[-1].Spinor[p2] -> {2, 
          2}}, {k2 -> (p1 + p2 - k1)}];

(*get the amplitudes, which have been written to a file by FeynArts*)
eezhamp = << eezhb.amp;

(*This calculates the amplitudes and sums them up*)
eezhboxes = OneLoopSum[eezhamp, CombineGraphs -> {1, 2, 3, 4, 5, 6}];

(*Here the result is written into a Mathematica file*)
Write2["eezhb.m", EEZHBOXES = FRH[eezhboxes]];

(*Here the result is written into a Mathematica program*)
Write2["eezhb.s", EEZHBOXES = eezhboxes];

(*Here the result is written into a Fortran file*)
Write2["eezhb.for", EEZHBOXES = eezhboxes, FormatType -> FortranForm];

\end{verbatim}
\end{footnotesize}
\begin{tabular*}{0.8\textwidth}{c}\hhline\end{tabular*}
\GrayCaption{Input program for calculating boxes of ${\rm e}^+{\rm e}^- \rightarrow  {\rm ZH}$.}
\end{figure}

\begin{figure}[H]
\begin{scriptsize}
\begin{verbatim}
        KK(1)= B0(MH2,MZ2,MZ2)
        KK(2)= B0(MZ2,ME2,ME2)
        KK(3)= B0(MH2,MW2,MW2)
        KK(4)= B0(MZ2,0D0,0D0)
        KK(5)= B0(MZ2,MW2,MW2)
        KK(6)= D0(MH2,ME2,MZ2,ME2,t,u,MZ2,MZ2,ME2,ME2)
        KK(7)= D0(MH2,MZ2,ME2,ME2,s,t,MW2,MW2,MW2,0D0)
        KK(8)= D0(MH2,MZ2,ME2,ME2,s,u,MW2,MW2,MW2,0D0)
        KK(9)= D0(MH2,ME2,MZ2,ME2,t,u,MW2,MW2,0D0,0D0)
        KK(10)= C0(MH2,t,ME2,MZ2,MZ2,ME2)
        KK(11)= C0(MH2,u,ME2,MZ2,MZ2,ME2)
        KK(12)= C0(MZ2,t,ME2,ME2,ME2,MZ2)
        KK(13)= C0(MZ2,u,ME2,ME2,ME2,MZ2)
        KK(14)= C0(MH2,MZ2,s,MW2,MW2,MW2)
        KK(15)= C0(MH2,t,ME2,MW2,MW2,0D0)
        KK(16)= C0(MH2,u,ME2,MW2,MW2,0D0)
        KK(17)= C0(MZ2,t,ME2,0D0,0D0,MW2)
        KK(18)= C0(MZ2,t,ME2,MW2,MW2,0D0)
        KK(19)= C0(MZ2,u,ME2,0D0,0D0,MW2)
        KK(20)= C0(MZ2,u,ME2,MW2,MW2,0D0)
        KK(21)= C0(s,ME2,ME2,MW2,MW2,0D0)
        KK(22)= B0(t,ME2,MZ2)
        KK(23)= B0(u,ME2,MZ2)
        KK(24)= B0(t,MW2,0D0)
        KK(25)= B0(u,MW2,0D0)
        KK(26)= 2*MH2 - MZ2
        KK(27)= MH2 - 5*MZ2
        KK(28)= 1 - 2*SW2
        KK(29)= MW2 + MZ2
        KK(30)= 2*MH2 - MW2
        KK(31)= MW2 + 2*MZ2
        KK(32)= 4*MW2**2 + 3*MW2*MZ2 - MZ2**2*SW2
        KK(33)= 5*MH2*MW2 - 2*MW2**2 + 2*MW2*MZ2 - MH2*MZ2*SW2
        KK(34)= MH2 - MW2 + 2*MZ2
        KK(35)= 2*MW2**2 + MW2*MZ2 - MZ2**2*SW2
        KK(36)= MW2 - MZ2*SW2
        KK(37)= MW2 + MZ2*SW2
        KK(38)= MH2 + MZ2
        KK(39)= 3*MW2 + MZ2*SW2
        KK(40)= MH2*MW2 + 4*MW2**2 + 2*MW2*MZ2 - 2*MZ2**2 + MH2*MZ2*SW2
        KK(41)= 2*MH2*MW2 - 2*MW2**2 + 4*MW2*MZ2 + MZ2**2*SW2
        KK(42)= 4*MH2 - 2*MW2 + 3*MZ2
        KK(43)= 2*MW2 - MZ2
        KK(44)= MH2*MW2 - 2*MW2**2 - 3*MW2*MZ2 + 2*MZ2**2 - MH2*MZ2*SW2
        KK(45)= MH2*MW2 + 4*MW2**2 + 4*MW2*MZ2 + MH2*MZ2*SW2
        KK(46)= 5*MW2 + MZ2*SW2
        KK(47)= 2*MH2 - MW2 + 2*MZ2
        KK(48)= 3*MH2*MW2 + 2*MW2**2 + 6*MW2*MZ2 + MH2*MZ2*SW2
        KK(49)= 9*MW2 + MZ2*SW2
        KK(50)= 2*MW2 + MZ2
        KK(51)= 3*MW2 + 2*MZ2
        KK(52)= MW2**2 - MH2*MZ2 + 3*MW2*MZ2 + MZ2**2
        KK(53)= 6*MH2*MW2 - 8*MW2**2 - MH2*MZ2*SW2 + MZ2**2*SW2
        KK(54)= MH2 - 2*MW2 + MZ2
        KK(55)= 4*MH2*MW2 - 4*MW2**2 - 2*MW2*MZ2 - MH2*MZ2*SW2 + MZ2**2*SW2
        KK(56)= MH2 - MZ2
        KK(57)= 2*MH2 + MZ2
        KK(58)= 2*MH2**2 + 4*MH2*MZ2 + MZ2**2
        KK(59)= MH2 - 2*MZ2
---> ... 418 lines omitted ...
        KK(173)= ALP4PI*FLUFAC*KK(172)
        EEZHBOXES = 2*KK(173)

\end{verbatim}
\end{scriptsize}
\begin{tabular*}{0.8\textwidth}{c}\hhline\end{tabular*}
\GrayCaption{Fortran output file "eezhb.for" generated by \mb{OneLoopSum} for ${\rm e}^+{\rm e}^- \rightarrow  {\rm ZH}$.}
\end{figure}

\begin{figure}[H]
\begin{scriptsize}
\begin{verbatim}

KK[1] = (B0[MH2, MZ2, MZ2]
       );
KK[2] = (B0[MZ2, SmallVariable[ME2], SmallVariable[ME2]]
       );
KK[3] = (B0[MH2, MW2, MW2]
       );
KK[4] = (B0[MZ2, 0, 0]
       );
KK[5] = (B0[MZ2, MW2, MW2]
       );
KK[6] = ( D0[MH2, SmallVariable[ME2], MZ2, SmallVariable[ME2], t, u, MZ2, MZ2, 
 SmallVariable[ME2], SmallVariable[ME2]]
       );
KK[7] = ( D0[MH2, MZ2, SmallVariable[ME2], SmallVariable[ME2], s, t, MW2, MW2, MW2, 0]
       );
KK[8] = ( D0[MH2, MZ2, SmallVariable[ME2], SmallVariable[ME2], s, u, MW2, MW2, MW2, 0]
       );
KK[9] = ( D0[MH2, SmallVariable[ME2], MZ2, SmallVariable[ME2], t, u, MW2, MW2, 0, 0]
       );
KK[10] = (C0[MH2, t, SmallVariable[ME2], MZ2, MZ2, SmallVariable[ME2]]
       );
KK[11] = (C0[MH2, u, SmallVariable[ME2], MZ2, MZ2, SmallVariable[ME2]]
       );
KK[12] = ( C0[MZ2, t, SmallVariable[ME2], SmallVariable[ME2], SmallVariable[ME2], MZ2]
       );
KK[13] = ( C0[MZ2, u, SmallVariable[ME2], SmallVariable[ME2], SmallVariable[ME2], MZ2]
       );
KK[14] = (C0[MH2, MZ2, s, MW2, MW2, MW2]
       );
KK[15] = (C0[MH2, t, SmallVariable[ME2], MW2, MW2, 0]
       );
KK[16] = (C0[MH2, u, SmallVariable[ME2], MW2, MW2, 0]
       );
KK[17] = (C0[MZ2, t, SmallVariable[ME2], 0, 0, MW2]
       );
KK[18] = (C0[MZ2, t, SmallVariable[ME2], MW2, MW2, 0]
       );
KK[19] = (C0[MZ2, u, SmallVariable[ME2], 0, 0, MW2]
       );
KK[20] = (C0[MZ2, u, SmallVariable[ME2], MW2, MW2, 0]
       );
KK[21] = (C0[s, SmallVariable[ME2], SmallVariable[ME2], MW2, MW2, 0]
       );
KK[22] = (B0[t, MZ2, SmallVariable[ME2]]
       );
KK[23] = (B0[u, MZ2, SmallVariable[ME2]]
       );
KK[24] = (B0[t, 0, MW2]
       );
KK[25] = (B0[u, 0, MW2]
       );
KK[26] = (2*MH2 - MZ2
       );
KK[27] = (MH2 - 5*MZ2
       );
KK[28] = (1 - 2*SW2
       );
KK[29] = (MW2 + MZ2
       );
KK[30] = (2*MH2 - MW2
       );
(* .............. 564 lines omitted ..................... *)
KK[173] = (ALP4PI*FLUFAC*HoldForm[KK[172]]
       );
EEZHBOXES = 2*HoldForm[KK[173]]

\end{verbatim}
\end{scriptsize}
\begin{tabular*}{0.8\textwidth}{c}\hhline\end{tabular*}
\GrayCaption{\mma output file "eezhb.s" generated by \mb{OneLoopSum} for ${\rm e}^+{\rm e}^- \rightarrow  {\rm ZH}$.}
\end{figure}

\subsection{Processing Amplitudes}
\label{process}

Calculating loop integrals will in many cases lead to very large expressions. The same goes for the application of other algorithms like Dirac tracing algorithms. The systematization and reduction of such expressions is a process which requires much more human planing, control and intervention than the process leading to the expressions. However, the computer is still of help. In this section shall be considered a few examples of how one may proceed, constructing small \mma programs taking advantage of tools provided by \fc.

\beom
\dtog{<< "eezhb.m"}{}{Load a stored amplitude (see section \ref{eezh}).}
\domtog{EEZHBOXES // LeafCount}{10415}{Check the 'size' of the expression.}
\dtog{eezhoxes = 
    Collect[EEZHBOXES // Expand, {ALP4PI, FLUFAC, \_MBM, \_D0, \_C0, \_B0}, 
      If[FreeQ[\#, \_MBM | \_D0 | \_C0 | \_B0 | \_PaVe], FullSimplify[\#], \#] \&];}{
}{
Expand the expressions, collect with respect to factors we know will be overall or "interesting", simplify what the non-overall factors multiply.}
\domtog{eezhoxes // LeafCount}{8881}{Check the "size" of the resulting expression.}
\dtog{DeleteFile /@ FileNames["eezhb*"];\\
DeleteFile /@ FileNames["PaVe*"];}{}{Clean up.}
\enom

In the example above, notice that instead of simply applying \mb{Simplify} to the whole expression, some grouping is first done and then \mb{Simplify} is applied to individual terms. This is often advantageous because the performance of \mb{Simplify} naturally scales very badly with the size of expressions. We remark that although \mb{OneLoopSum} does a decent job in structuring the expression, it can still be reduced somewhat.

In the one-loop calculations considered thus far, amplitudes have been computed. The extra step of computing the (differential) cross section can also be done with \fc. To demonstrate this we pick a very simple example, namely the famous M{\o}ller cross section. This example also demonstrates that a full calculation from Feynman rules to cross section can be carried out with \fa and \fc \footnote{In fact, as we have seen in section \ref{Green}, calculation of Feynman rules from  lagrangians can also be automatized with \fc.}.

\begin{figure}[H]
\begin{footnotesize}
\begin{verbatim}

(*Construction of topologies*)
tops = CreateTopologies[0, 2 -> 2, Adjacencies -> {3}, 
      ExcludeTopologies -> {SelfEnergies, WFCorrections}];

(*Check*)
Paint[tops, ColumnsXRows -> {3, 1}, AutoEdit -> False];

(*Field insertion*)
inserttops = 
    InsertFields[tops, {F[1, {1}], F[1, {1}]} -> {F[1, {1}], F[1, {1}]}, 
      Model -> "QED", GenericModel -> "QED", InsertionLevel -> Particles];

(*Check*)
treegraphs = 
    Paint[inserttops, PaintLevel -> {Particles}, AutoEdit -> False, 
      SheetHeader -> False, Numbering -> False, ColumnsXRows -> {2, 1}];

(*Calculate the amplitudes*)
amps = CreateFeynAmp[inserttops, AmplitudeLevel -> Particles];

(*Save result*)
PickLevel[Classes][amps] // ToFA1Conventions >> "moelleramps.m"

\end{verbatim}
\end{footnotesize}
\begin{tabular*}{0.8\textwidth}{c}\hhline\end{tabular*}
\GrayCaption{For completeness here is the input program for generating the (leading order) diagrams of M{\o}ller scattering with \fa.}
\end{figure}

\begin{figure}[H]
\begin{footnotesize}
\begin{verbatim}

(*Define the Mandelstam variables and put momenta on - shell*)
  SetMandelstam[s, t, u, p1, p2, -k1, -k2, ME, ME, ME, ME];

(*get the amplitudes, which have been written to a file by FeynArts*)
amps = << moelleramps.m;

(*Sum the graphs and contract Lorentz indices*)
amp = (OneLoopSum[amps, CombineGraphs -> {1, 2}] // FRH) /. D :> Sequence[] //
     Contract

(*Square the amplitude, 
  transform the spin sums into traces and evaluate the traces*)
squaredamp = 
  FermionSpinSum[amp ComplexConjugate[amp /. li2 -> li1] // Expand] /. 
          DiracTrace -> Tr // DiracSimplify // 
      TrickMandelstam[#, {s, t, u, 4ME^2}] & // Simplify
squaredamp1 = 
  squaredamp // Contract // PropagatorDenominatorExplicit // Simplify

(*The kinematical factor in the center of mass frame*)
kinfac = 1/(64 \[Pi]^2s);

(*The full differential cross section in the center of mass frame expressed \
in terms of Mandelstam variables*)
dcrosssection = 1/4*kinfac*squaredamp1 // Simplify
(*Shift to other variables : Scattering angle and half the CMS energy*)
dc = dcrosssection /. u -> 4ME^2 - s - t /. {s -> 4 \[Omega]^2, 
          t -> -2 q2(1 - Sqrt[1 - sin[\[Theta]]^2])} /. 
      q2 -> \[Omega]^2 - ME^2 // Simplify

(*Clean up*)
DeleteFile["moelleramps.m"];

\end{verbatim}
\end{footnotesize}
\begin{tabular*}{0.8\textwidth}{c}\hhline\end{tabular*}
\GrayCaption{Calculation of the M{\o}ller cross section.}
\end{figure}

Notice that the argument given to \mb{FermionspinSum} is a product of two amplitudes. These both
contain contracted indices; therefore, in one of them, these indices have to be renamed. The
functions \mb{TrickMandelstam} and \mb{PropagatorDenominatorExplicit} are described in section
\ref{misc}.

\otabtwo{
\mbs{ComplexConjugate[{\sl exp}]} & conjugates the expression {\sl exp}, operating on fermion
lines \cr
\mbs{FermionSpinSum[{\sl exp}]} & constructs traces out of squared amplitudes \cr
}{Calculation of squares of fermion amplitudes.}

