\section{Chiral Perturbation Theory}

\subsection{Introduction}

The package \fphi (Phenomenology of Hadronic Interactions) provides utilities for computations in
the Chiral Perturbation Theory (ChPT).
The general idea is to allow writing up a calculation starting with a lagrangian and ending up
with an amplitude, all within the framework of \fc. For this to be possible, many functions on a
rather general level were implemented, as was a method of interacting seamlessly with \fa. The
following sections cover the more important features of the package. A fuller description can be
found in \cite{PHI}.

The motivation for writing \fphi was a lack of software for implementing an effective model like 
one of the various ChPT models, which have a more complicated power counting than models which 
simply expand Green's functions perturbatively in a coupling constant. However, the package is 
general enough that other models can be defined, as has been demonstrated with the simple example 
of QED.
% TODO: Add reference to calculations with other models
% (HQET, soft collinear effective field theory??)

The main features of \fphi are:
\begin{itemize}
\item A set of basic objects are provided that can be composed and manipulated to form ChPT
lagrangians.
\item The most common ChPT lagrangians are included and new ones can easily be defined.
\item The lagrangians can be expanded in terms of pion (meson) fields, with SU(2) (SU(3)) flavour
traces being done automatically.
\item External sources can be switched off and on.
\item \fa is used for generating Feynman diagrams and amplitudes, including counter-terms. Power
counting and storing of Feynman rules is systematized.
\end{itemize}

\subsection{Models and Lagrangians}

\fphi comes with a number of predefined chiral models (or configurations). These define
lagrangians etc. in terms of quantum fields. Which configuration and lagrangians are loaded should
be defined before startup of \fc. When loading a langrangian, it is added to the database of
lagrangians, \mb{Lagrangian}. In section \ref{modelDefs} is discussed how to construct such
lagrangians.

\beom
\dtog{
Quit[];\\\\
\$LoadPhi = True;\\
\$LoadFeynArts = True;\\
\$Configuration = "ChPTVirtualPhotons2";\\
\$Lagrangians = {"ChPTVirtualPhotons2"[2], \\
\mindent "ChPTVirtualPhotons2"[4]};\\\\
Get["HighEnergyPhysics`FeynCalc`"];\\}{}{Quit the kernel and reload \fc with the packages \fphi and \fa enabled. Have \fphi load "ChPTVirtualPhotons2" and its two lagrangians.}
\domtog{Lagrangian[ChPTVirtualPhotons2[2]]}{$
\frac{1}{4}\multsp \big(\langle \chi \SixPointedStar {{\ScriptCapitalU \
}^{\dagger }}\rangle + \langle {{\chi }^{\dagger }}\SixPointedStar \
\ScriptCapitalU \rangle + \langle {{\ScriptCapitalD }_{\mu \
}}(\ScriptCapitalU )\SixPointedStar {{{{\ScriptCapitalD }_{\mu \
}}(\ScriptCapitalU )}^{\dagger }}\rangle \big)\multsp {{(f_{\pi \
})}^2} - \frac{1}{2}\multsp \lambda \multsp {{\partial }_{\mu \
}}\big({{{{\gamma }}}_{\mu }}\big)\multsp {{\partial }_{\nu \
}}({{{{\gamma }}}_{\nu }}) - \frac{1}{4}\multsp \big({{{{\gamma \
}}}_{\mu \nu }}\SixPointedStar {{{{\gamma }}}_{\mu \nu }}\big) +  \\
{{C}}\multsp \langle {{Q}_{R}}\SixPointedStar \
\ScriptCapitalU \SixPointedStar {{Q}_{L}}\SixPointedStar \
{{\ScriptCapitalU }^{\dagger }}\rangle$}{Inspect the leading order lagrangian.}
\enom

\mb{\$Configuration} is a short name denoting some physics model, in the case above, ChPT
with virtual photons in SU(2). \$Lagrangians is then a list of the lagrangians defined with
this model, in the case above the lagrangians of leading and next-to-leading order ( 2 and 4)
in the chiral expansion.

\otabtwo{
\mbs{\$Configuration} & string valued variable determining which configuration is loaded at
startup\cr
\mbs{\$Lagrangians} & string valued variable determining which lagrangians are loaded at
 startup\cr
}{\fphi startup settings.}
The list of available configurations and lagrangians can be found by browsing the directory
"HighEnergyPhysics/Phi/Configurations" and "HighEnergyPhysics/Phi/Lagrangians".
Currently the list reads
\otabtwo{
\mbs{"ChPT2"} & ChPT with in SU(2)\cr
\mbs{"ChPT3"} & ChPT in SU(3)\cr
\mbs{"ChPTVirtualPhotons2"} & ChPT in SU(2) with virtual photons\cr
\mbs{"ChPTVirtualPhotons3"} & ChPT in SU(3) with virtual photons\cr
\mbs{"ChPTPhotonsLeptons3"} & ChPT in SU(3) with virtual photons and leptons\cr
\mbs{"ChPTW3"} & ChPT in SU(3) with $\Delta I$=1 weak interaction\cr
}{\fphi Possible settings of \mb{\$Configuration}.}

\subsection{Quantum Fields and their Space-Time Derivatives}

The field argument of \mb{QuantumField} can be any symbol. Notice however, that the various configurations files for \fphi each use some conventions; e.g. for a pion the symbol \mb{Particle[Pion]} is used. The Dirac bar can be applied to fermionic \mb{QuantumField}s with the function \mb{DiracBar}. Since partial derivatives and covariant derivatives may be performed on \mb{QuantumField}s as well as on polynomials of \mb{QuantumField}s, the \mb{QuantumField}s usually carry a space-time argument, e.g. $x$. For the derivatives, the functions, \mb{FieldDerivative} and \mb{CovariantFieldDerivative} are provided. As already seen, an equivalent way of calculating space-time derivatives is using ``\mb{$.$}'' and the operators of page \pageref{partialDs}. The ``\mb{$.$}'' operator is, however, also used for multiplying Dirac matrices, so to avoid confusion \mb{FieldDerivative} may be used.

\beom
\domtog{
FieldDerivative[QuantumField[p][x], x, LorentzIndex[$\bm{\mu}$]]
}{$\partial_\mu\pi$}{A single derivative of some field $p$.}
\domtog{\% // StandardForm}{QuantumField[PartialD[LorentzIndex[$\mu$]], p][x]}{The result is expressed using the symbol \mb{PartialD}.}
\domtog{
\mb{CovariantFieldDerivative[QuantumField[Particle[\\
\mindent Pion]][x]\phat 2, x, LorentzIndex[$\bm{\mu}$]]//\\
CommutatorReduce}
}{
$\ComplexI \pi^2\, \left( \overrightarrow{V_\mu} \cdot
               \overrightarrow{\bm{\sigma}}\, -\,
                     \overrightarrow{A_\mu} \cdot \overrightarrow{\bm{\sigma}}
                     \right)\, -\, 
\ComplexI \left( \overrightarrow{A_\mu} \cdot \overrightarrow{\bm{\sigma}}\, +\,
                \overrightarrow{V_\mu} \cdot \overrightarrow{\bm{\sigma}}\right)
                     \pi^2 \, +\,\\
\ComplexI \gamma_\mu Q_{\rm\bf L}\, \pi^2\, -\, \ComplexI \gamma_\mu Q_{\rm\bf R}\, \pi^2\, +
2\pi\, \partial_\mu\pi$
}{The covariant derivative of the squared pion field (defined by the loaded model),
$D_\mu \phi_\pi^2$.}
\enom

\mb{CommutatorReduce} pulls out abelian quantities of non-abelian products (see below).

\otabtwo{
\mbs{\mb{FieldDerivative[g[x], x, \{{\sl l1}, {\sl l2}, ...\}]}} & calculates
$\frac{\partial}{\partial {\sl x}_{\sl l1}}\frac{\partial}{\partial {\sl x}_{\sl l2}}\ldots$ on
the expression \mb{g[{\sl x}]}\cr
\mbs{\mb{CovariantFieldField Derivative[g[{\sl x}], {\sl x}, \{{\sl l1}, {\sl l2}, ...\}]}} &
as above but with the vector and axial-vector source field  terms included. This is
defined in the chosen configuration file\cr
}{Derivatives acting on \mb{QuantumField}s.}

Many operations can be performed on expressions involving \mb{QuantumField}s. We shall see some in
the examples to come. But first we turn to some of the objects that \fphi adds to the basic
framework of \fc. Notice that in ChPT, a condensed notation is used and many objects like e.g.~the
basic \mb{MM[x]}, which is the \fphi notation for the $U$ of ChPT, actually contain
\mb{QuantumField}s \footnote{Remember that an explanation of the various symbols can be obtained
by using the \mb{?} operator.}.

\subsection{Vectors, Matrices and Structure Constants in SU(2) and SU(3)}

\mb{QuantumField}s may be grouped in flavour SU($N$) matrices or vectors\footnote{with SU($N$) we shall understand  SU($N$), where $N$=2 or 3.} with the functions \mb{IsoVector}, \mb{UMatrix} and \mb{UVector}. When this is done, these functions take over the space-time argument.

\otabtwo{
\mbs{IsoVector[{\sl v}]} & represents an SU(2) or SU(3) multiplet with number of
entries corresponding to the number of generators (3 or 8)\cr
\mbs{UVector[{\sl v}]} & represents an SU(2) or SU(3) vector with number of entries
corresponding to the dimension of the representation (2 or 3)\cr
\mbs{UMatrix[{\sl m}]} & is recognized as a square matrix of dimension 2 or 3\cr
}{SU($N$) vectors and matrices.}

\otabthree{
{\sl option name} & {\sl default value} &\cr
\hhline
\mbs{SUNN} & \mb{2} & number of quark flavours. Either 2 or 3 \cr
\mbs{UDimension} & \mb{Automatic} & dimension of the representation\cr
}{Options determining the dimension of SU($N$) vectors and matrices.}

The SU($N$) matrices and vectors may be multiplied with each other using some new functions; \mb{NM} (``\mb{$\SixPointedStar$}'' in \mb{OutputForm}) is used for multiplication of SU($N$) matrices, \mb{IsoDot} (``\mb{$\cdot$}'') is used for the dot product of SU($N$) iso-vectors. The \mma \mb{Dot} (``\mb{.}'') is used for multiplication of SU($N$) matrices with SU($N$) vectors. SU($N$) matrices may be adjoined, conjugated and transposed.

\beom
\domtog{IsoDot[IsoVector[a], IsoVector[b]]}{$\overrightarrow{a} \cdot \overrightarrow{b}$}{Dot product of two iso-vectors.}
\domtog{UVector[\mb{$\overvar{\Psi}{\_}$}] . NM[ IsoDot[IsoVector[a],
    IsoVector[UMatrix[b]]], Adjoint[UMatrix[c]]] .
    UVector[\mb{$\Psi$}]}{$\overvar{\overvar{\Psi }{\_}}{\rightharpoonup}.
   \bigg(\overvar{a}{\rightarrow}\cdot \overvar{b}{\rightarrow}\SixPointedStar c^\dagger\bigg).
   \overvar{\Psi }{\rightharpoonup}$}{A more complicated structure. Iso-vectors of SU($N$) matrices are allowed.}
\enom

\otabtwo{
\mbs{NM[{\sl a}, {\sl b}, \ldots]} & non-commutative multiplication for matrices and/or fields {\sl a}, {\sl b}, \ldots \cr
\mbs{IsoDot[{\sl a}, {\sl b}]} & dot product for iso-vectors {\sl a}, {\sl b}\cr
\mbs{IsoCross[{\sl a}, {\sl b}]} & anti-symmetric cross product for isospin vectors {\sl a}, {\sl b}\cr
\mbs{IsoSymmetricCross} & symmetric cross product for isospin vectors {\sl a}, {\sl b}\cr
\mbs{Dot[{\sl a}, {\sl b}]} & the usual dot product, ``\mb{.}'', is used for multiplication of \mb{UVectors} with \mb{UVectors} or \mb{UMatrices}\cr
}{Multiplication operators for SU($N$) vectors and matrices.}

\otabtwo{
\mbs{Adjoint[{\sl m}]} & the adjoint {\sl m}$^\dagger$ of a matrix {\sl m}\cr
\mbs{Conjugate[{\sl m}]} & the conjugate {\sl m}$^{\rm c}$ of a matrix {\sl m}\cr
\mbs{Transpose[{\sl m}]} & the transpose {\sl m}$^{\rm t}$ of a matrix {\sl m}\cr
}{Operations on matrices.}

The matrices generating flavour SU($N$) are denoted \mb{UGenerator}.

\otabtwo{
\mbs{UGenerator[{\sl i}]} & \mb{UMatrix[UGenerator[{\sl i}]]} is the {\sl i}'th generator of SU($N$) 
}{Generators of flavour SU(2) or SU(3).}

SU($N$) vectors and matrices may be written out explicitly using
\mb{WriteOutUMatrices} and/or \mb{WriteOutIsoVectors}.

\otabtwo{
\mbs{WriteOutUMatrices[{\sl exp}]} & write out SU($N$) vectors in {\sl exp}\cr
\mbs{WriteOutIsoVectors[{\sl exp}]} & write out SU($N$) matrices in {\sl exp}\cr
}{Writing out explicit components of SU($N$) vectors and matrices.}

\beom
\domtog{IsoDot[IsoVector[a], IsoVector[b]] // WriteOutIsoVectors}{${{a(1)}^{\GothicC }}\SixPointedStar b(1)+{{a(2)}^{\GothicC }}\SixPointedStar b(2)+
   {{a(3)}^{\GothicC }}\SixPointedStar b(3)$}{The dot product of two iso-vectors, $a$ and $b$. Notice that the default is to assume non-commutativity and use \mb{NM} for multiplication.}
\domtog{UMatrix[a] // WriteOutUMatrices}{$\big(\NoBreak \MathBegin{MathArray}[c]{cc}
  a(1,1)&a(1,2) \\
  a(2,1)&a(2,2)
     \MathEnd{MathArray}\NoBreak \big)$}{Some matrix, $a$, written out in components.}
\domtog{UMatrix[UGenerator[1]] // WriteOutUMatrices}{$\big(\NoBreak
  \MathBegin{MathArray}[c]{cc}
  0&-1 \\
  -1&0 
  \MathEnd{MathArray}\NoBreak \big)$}{The first generator of SU($N$) written out in components.
In this case, the first of the triplet of
generators of SU(2), because the default value of the option \mb{SUNN} of \mb{UMatrix} has been set to 2 by the active model file.}
\domtog{IsoVector[UMatrix[UGenerator[]]]}{$\overvar{\bm{\sigma}}{\rightarrow}$}{
The triplet of generators of SU(2).}
\domtog{\% // WriteOutIsoVectors}{$\langle {{\bm{\sigma}}^1},{{\bm{\sigma}}^2},{{\bm{\sigma} }^3}\rangle$}{}
\domtog{\% // WriteOutUMatrices}{$\langle \big(\NoBreak \MathBegin{MathArray}[c]{cc}
  0&-1 \\
  -1&0 
  \MathEnd{MathArray}\NoBreak 
     \big),\big(\NoBreak \MathBegin{MathArray}[c]{cc}
  0&-\ImaginaryI  \\
  \ImaginaryI &0 
 
       \MathEnd{MathArray}\NoBreak \big),
    \big(\NoBreak \MathBegin{MathArray}[c]{cc}
  -1&0 \\
  0&1 
  \MathEnd{MathArray}\NoBreak \big)
    \rangle$}{}
\enom

Products using the multiplication operators for SU($N$) vectors and matrices may be written out  using contracted symbolic indices with the function \mb{IsoIndicesSupply}.

\otabtwo{
\mbs{IsoIndicesSupply[{\sl exp}]} & replaces dot and cross products of SU($N$) vectors with
contracted indices\cr
}{Writing out components of SU($N$) vectors and matrices using symbolic indices.}

\beom
\domtog{IsoDot[IsoVector[a], IsoVector[b]] // IsoIndicesSupply}{
${{a({{i}_1})}^{\GothicC}}\SixPointedStar b({{i}_1})$}{Write out a dot-product with a contracted index.}
\enom

Applying \mb{IsoIndicesSupply} on expressions using \mb{IsoDot}, etc.~will typically result in
expressions involving the Kronecker delta function and the structure constants of SU($N$), with
$N=2$ or $N=3$, depending on the setting of the option \mb{SUNN}.

\otabtwo{
\mbs{SU2Delta[{\sl i}, {\sl j}]} & the Kronecker delta function $\delta_{i j}$ in SU(2)\cr
\mbs{SU2F[{\sl i}, {\sl j}, {\sl k}]} & the antisymmetric structure constants $d_{i j k}$ in SU(2)\cr
\mbs{SU3Delta[{\sl i}, {\sl j}]} & the Kronecker delta function $\delta_{i j}$ in SU(3)\cr
\mbs{SU3F[{\sl i}, {\sl j}, {\sl k}]} & the antisymmetric structure constants $d_{i j k}$ in SU(3)\cr
\mbs{SU3D[{\sl i}, {\sl j}, {\sl k}]} & the symmetric structure constants $d_{i j k}$ in SU(3)\cr
}{The Kronecker delta function and the structure constants of SU(2) and SU(3).}

To reduce or otherwise manipulate expressions expressions involving SU($N$) indices and/or non-commutative multiplication of SU($N$) matrices, the three functions listed below are
provided.

\otabtwo{
\mbs{IndicesCleanup[{\sl exp}]} & renames Lorentz and SU($N$) indices in a systematic way\cr
\mbs{SUNReduce[{\sl exp}]} & does some reduction on expressions involving SU($N$) indices\cr
\mbs{CommutatorReduce[{\sl exp}]} & does some reduction on expressions containing non-abelian  SU($N$) products in {\sl exp}\cr
}{SU($N$) utilities.}

To calculate the trace of flavour SU($N$) matrices, the function \mb{Utrace} is used.
This function distributes over sums. If the trace of a term is not known, \mb{Utrace} is
simply replaced with \mb{Utrace1}, which displays in \mb{TraditionalForm} as $\braket{\cdots}$.

\otabtwo{
\mbs{UTrace[{\sl m}]} & calculate the flavour SU($N$) trace of the matrix {\sl m} \cr
\mbs{UTrace1[{\sl m}]} & return value if the trace of {\sl m} is not known \cr
}{The trace of flavour SU($N$) matrices.}

\beom
\dtog{id = IsoDot;\\
iv = IsoVector;\\
ug = IsoVector[UMatrix[UGenerator[]]];}{}{A few abbreviations}
\domtog{UTrace[\\
    NM[id[iv[a], ug] + id[iv[d], ug], \\
    \mindent id[iv[b], ug], id[iv[c], ug]] - \\
    NM[id[iv[b], ug], id[iv[c], ug], \\
    \mindent id[iv[a], ug]]]}{$\langle \bigg(\overvar{a}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }+
        \overvar{d}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }\bigg)\SixPointedStar
       \overvar{b}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }\SixPointedStar 
     \overvar{c}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }\rangle -
   \langle \overvar{b}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }\SixPointedStar 
      \overvar{c}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }\SixPointedStar 
     \overvar{a}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }\rangle$}{A deceptively complicated example,
$\langle \bigg(\overvar{a}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }+
        \overvar{d}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }\bigg)
       \overvar{b}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow } 
     \overvar{c}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }\rangle -
   \langle \overvar{b}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow } 
      \overvar{c}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow } 
     \overvar{a}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }\rangle$}
\domtog{\% // NMExpand // CycleUTraces}{$\langle \overvar{b}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }\SixPointedStar 
     \overvar{c}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }\SixPointedStar 
    \overvar{d}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }\rangle$}{Expanding the non-commutative products causes the trace to distribute over the sum. Cycling the trace to a unique form can often cause some cancellation.}
\domtog{\% // ExpandU}{$2\multsp \ImaginaryI \multsp \overvar{{b^{\GothicC }}}{\rightarrow }\times \overvar{c}{\rightarrow }\cdot \overvar{{d^{\GothicC }}}{\rightarrow }$}{When the monomials of
generator matrices are reduced to order 1 or 0, the trace is known.}
\domtog{\% // IsoIndicesSupply // CommutatorReduce}{$2\multsp \ImaginaryI \multsp {{b({{i}_2})}^{\GothicC }}\multsp {{c({{i}_3})}^{\GothicC }}
   \multsp {{d({{i}_4})}^{\GothicC }}\multsp {f_{{{i}_2}{{i}_3}{{i}_4}}}$}{Indices are supplied. Vector products are thereby written in terms of the SU($N$) structure constants.}
\enom

\otabtwo{
\mbs{NMExpand[{\sl exp}]} & expand any \mb{NM} products in {\sl exp} using distributivity \cr
\mbs{CycleUTraces[{\sl exp}]} & Use cyclicity to write all traces in a canonical form\cr
\mbs{ExpandU[{\sl exp}]} & expand \mb{IsoDot} products involving generator matrices
into products containing at most one generator matrix.\cr
}{Utilities for manipulating non-commutative products of falvour SU($N$) matrices.}

These functions each take a number of options, allowing to tune their behaviour.
In particular, \mb{SUNReduce} takes the option \mb{FullReduce}, which, when set to \mb{True}
triggers some extra reduction and iterates until the result no longer changes.
By default it is set to \mb{False}, so, iterated application on an expression can cause
the result to change on each iteration.

\otabthree{
{\sl option name} & {\sl default value} &\cr
\hhline
\mbs{FullReduce} & \mb{False} & iterate until the result no longer changes \cr
\mbs{Explicit} & \mb{False} & perform explicit sums over repeated indices \cr
\mbs{HoldSums} & \mb{True} & when \mb{Explicit} is set to \mb{True},
                             only write the summation symbols, don't do the summations \cr
\mbs{SUNN} & \mb{2} & dimension of the representation\cr
}{Options of \mb{SUNReduce}.}

\beom
\domtog{k(IsoDot[IsoCross[IsoVector[a], IsoVector[b]], 
          IsoCross[IsoVector[a], IsoVector[b]]] + 
        IsoDot[IsoCross[IsoVector[a], IsoVector[c]], 
          IsoCross[IsoVector[a], IsoVector[c]]])}{
$k\multsp \bigg(\overvar{a}{\rightarrow }\times \overvar{b}{\rightarrow }\cdot 
      \overvar{a}{\rightarrow }\times \overvar{b}{\rightarrow }+
     \overvar{a}{\rightarrow }\times \overvar{c}{\rightarrow }\cdot 
      \overvar{a}{\rightarrow }\times \overvar{c}{\rightarrow }\bigg)$}{Another deceptively complicated example.}
\domtog{\% // IsoIndicesSupply}{
$k\multsp \big(
    (a({{i}_2})\SixPointedStar {{b({{i}_3})}^{\GothicC }}\SixPointedStar 
         {{a({{i}_4})}^{\GothicC }}\SixPointedStar b({{i}_5}))\multsp 
      {f_{{{i}_{10}}{{i}_2}{{i}_3}}}\multsp {f_{{{i}_{10}}{{i}_4}{{i}_5}}}+\\
 (a({{i}_6})\SixPointedStar {{c({{i}_7})}^{\GothicC }}\SixPointedStar 
        {{a({{i}_8})}^{\GothicC }}\SixPointedStar c({{i}_9}))\multsp 
     {f_{{{i}_{11}}{{i}_6}{{i}_7}}}\multsp {f_{{{i}_{11}}{{i}_8}{{i}_9}}}\big)$}{Write out with contracted indices.}
\domtog{\% // CommutatorReduce}{
$k\multsp \big(
    a({{i}_2})\multsp b({{i}_5})\multsp {{a({{i}_4})}^{\GothicC }}\multsp 
      {{b({{i}_3})}^{\GothicC }}\multsp {f_{{{i}_{10}}{{i}_2}{{i}_3}}}\multsp 
      {f_{{{i}_{10}}{{i}_4}{{i}_5}}}+\\
 a({{i}_6})\multsp c({{i}_9})\multsp {{a({{i}_8})}^{\GothicC }}\multsp 
     {{c({{i}_7})}^{\GothicC }}\multsp {f_{{{i}_{11}}{{i}_6}{{i}_7}}}\multsp 
     {f_{{{i}_{11}}{{i}_8}{{i}_9}}}\big)$}{If variables have not been explicitly declared as non-commutative,
\mb{CommutatorReduce} pulls them out of the non-commutative product \mb{NM}.}
\domtog{\% // IndicesCleanup}{
$-k\multsp a({{k}_1})\multsp b({{k}_2})\multsp 
    {{a({{k}_5})}^{\GothicC }}\multsp {{b({{k}_4})}^{\GothicC }}\multsp 
    {f_{{{k}_1}{{k}_3}{{k}_4}}}\multsp {f_{{{k}_2}{{k}_3}{{k}_5}}}-\\
 k\multsp a({{k}_1})\multsp c({{k}_2})\multsp 
   {{a({{k}_5})}^{\GothicC }}\multsp {{c({{k}_4})}^{\GothicC }}\multsp 
   {f_{{{k}_1}{{k}_3}{{k}_4}}}\multsp {f_{{{k}_2}{{k}_3}{{k}_5}}}$}{
\mb{IsoIndicesSupply} increments the index number. To have indices renamed in a
unique and minimal way, use \mb{IndicesCleanup}.}
\domtog{\% // SUNReduce // Simplify}{
$k\multsp a({{k}_1})\multsp {{a({{k}_5})}^{\GothicC }}\multsp 
   (b({{k}_2})\multsp {{b({{k}_4})}^{\GothicC }}+
     c({{k}_2})\multsp {{c({{k}_4})}^{\GothicC }})\multsp
     \big(\delta _{{{k}_1}{{k}_5}}^{(2)}\multsp 
     \delta _{{{k}_2}{{k}_4}}^{(2)}-
    \delta _{{{k}_1}{{k}_2}}^{(2)}\multsp \delta _{{{k}_4}{{k}_5}}^{(2)}\big)$}{By default, \mb{SUNReduce} just applies its reduction rules once.}
\domtog{SUNReduce[\%, FullReduce \bm{$\rightarrow$} True] // Simplify}{
$k\multsp a({{k}_1})\multsp
   (b({{k}_2})\multsp {{a({{k}_1})}^{\GothicC }}\multsp 
     {{b({{k}_2})}^{\GothicC }}-b({{k}_1})\multsp {{a({{k}_4})}^{\GothicC }}\multsp 
     {{b({{k}_4})}^{\GothicC }}+ \\
     c({{k}_2})\multsp {{a({{k}_1})}^{\GothicC }}\multsp 
     {{c({{k}_2})}^{\GothicC }}-
 c({{k}_1})
     \multsp {{a({{k}_4})}^{\GothicC }}\multsp {{c({{k}_4})}^{\GothicC }})$}
{Tell \mb{SUNReduce} to fully reduce the expression.}
\domtog{\% // IndicesCleanup // Simplify}{
$k\multsp a({{k}_1})\multsp
   (b({{k}_1})\multsp (
      {{a({{k}_1})}^{\GothicC }}\multsp {{b({{k}_1})}^{\GothicC }}-
       {{a({{k}_4})}^{\GothicC }}\multsp {{b({{k}_4})}^{\GothicC }})+
 c({{k}_1})\multsp 
     ({{a({{k}_1})}^{\GothicC }}\multsp {{c({{k}_1})}^{\GothicC }}-
       {{a({{k}_4})}^{\GothicC }}\multsp {{c({{k}_4})}^{\GothicC }}))$}
{Now, \mb{IndicesCleanup} can bring some further simplification.}
\dtog{Clear[a,b,c,d];}{}{Clean up.}
\enom

\otabtwo{
\mbs{DeclareUMatrix[{\sl a}]} & causes the symbol {\sl a} to be treated as a flavour SU($N$) matrix \cr
\mbs{DeclareUScalar[{\sl a}]} & causes the symbol {\sl a} to be treated as a flavour SU($N$) scalar \cr
\mbs{UndeclareUMatrix[{\sl a}]} & causes the symbol {\sl a} to seize being treated as a flavour SU($N$) matrix \cr
\mbs{UndeclareUScalar[{\sl a}]} & causes the symbol {\sl a} to seize being treated as a flavour SU($N$) scalar \cr
}{Matrices and scalars of SU(2) or SU(3).}

\subsection{Model and Lagrangian Definitions}
\label{modelDefs}

In ChPT one finds a number of symbols representing matrices of fields with various
transformation properties under SU($N$)$\times$SU($N$). Some of these symbols are common
to all ChPT models and are provided by the package \fphi itself, others are defined in
the model files and are only available upon loading the right configuration.

The constants of the various models usually have head \mb{ParticleMass},
\mb{CouplingConstant} or \mb{DecayConstant}. 

\otabtwo{
\mbs{ParticleMass[{\sl p}]} & mass of the particle {\sl p}\cr
\mbs{CouplingConstant[{\sl c}]} & some coupling constant {\sl c}\cr
\mbs{DecayConstant[{\sl p}]} & decay constant of the particle {\sl p}\cr
}{Heads for physical constants.}

As we have seen, the convention used for the symbols representing quantum fields used in ChPT
is to give them the head \mb{Particle}. This is in order to be able to have an extra argument
specifying whether a quantity is renormalized or not.

\otabtwo{
\mbs{Particle[{\sl p}]} & represents a particle or source
{\sl p} should be a member of the list \mb{\$Particles}\cr
\mbs{\$Particles} & a list of available particles and sources of the active configuration (\mb{\$Configuration})\cr
}{Particle names.}

\otabtwo{
\mbs{RenormalizationState[{\sl i}]} & tag a quantity as unrenormalized ({\sl i}=0) or renormalized ({\sl i}=1)\cr
}{Option of \mb{Particle}.}

A number of matrices and constants, commonly used in ChPT are predefined by the main
package \fphi and listed below. Others are defined by the individual model definition files.
As always, to get information about these, use the \mb{?} operator.

\otabtwo{
\mbs{UQuarkMass[]} & \mb{UMatrix[UQuarkMass[]]} is the quark mass matrix\cr
\mbs{UChi[]} & \mb{UMatrix[UChi[]]} is the $\chi$ of ChPT\cr
\mbs{MM[{\sl x}]} & the $U$ of ChPT. Notice that \fphi displays this as $\ScriptCapitalU$\cr
\mbs{SMM[{\sl x}]} & the $u$ of ChPT ($u^2 = U$). Notice that \fphi displays this as $\ScriptU$\cr
\mbs{QuarkCondensate[]} & the quark condensate $B_0 = \braket{ 0 | q \bar{q} | 0 }$\cr
}{ChPT symbols available under all configurations.}

The predefined matrices are typically used when building up the lagrangians corresponding to
the model. The definition of a lagrangian should be in a file in the directory
"HighEnergyPhysics/Phi/Lagrangians" the name of which should indicate the model to which
it belongs (defined by a file in the directory "HighEnergyPhysics/Phi/Configurations").
To keep the definition compact and to allow inspection of the unexpanded form, the convention
is to not give the meson matrix $U$ (\mb[MM]) and other similar matrices any space-time argument
nor any option specifying the expansion order or renormalization state.
These arguments will be supplied automatically by the function \mb{ArgumentsSupply}.

\otabtwo{
\mbs{ArgumentsSupply[{\sl exp}, {\sl x}, {\sl opts}]} & supply space-time argument {\sl x} and
options {\sl opts} to matrix functions in {\sl exp}\cr
}{Writing out predefined lagrangians.}

\otabthree{
{\sl option name} & {\sl default value} &\cr
\hhline
\mbs{ExpansionOrder} & \mb{4} & order of expansion in the meson field \cr
\mbs{DropOrder} & \mb{4} & power of the meson field, higher orders than which will be dropped \cr
}{Controlling the expansion in the meson field.}

\beom
\domtog{UTrace[NM[UChiMatrix, Adjoint[MM]]]}{
$\langle \chi \SixPointedStar {{\ScriptCapitalU }^{\dagger }}\rangle$}
{Here is a piece of the leading order lagrangian. Notice that space-time arguments have not been supplied.}
\domtog{UTrace[NM[UChiMatrix[x], Adjoint[MM[x]]]]}{
$2\multsp \ScriptCapitalB _{0}\multsp
 \langle \bigg(
     \frac{\DoubleStruckCapitalI \DoubleStruckD \multsp {{(m_{\pi })}^2}}
       {2\multsp \ScriptCapitalB _{0}}+
      \overvar{{{s}}}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }+
      \DoubleStruckCapitalI \DoubleStruckD \multsp {{{{s}}}^0}\bigg)\SixPointedStar \\
      \Bigg(-\frac{\ImaginaryI \multsp \overvar{{{\pi }}}{\rightarrow }\cdot 
        \overvar{\sigma }{\rightarrow }}{f_{\pi }}-
   \frac{\overvar{{{\pi }}}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }
      \SixPointedStar \overvar{{{\pi }}}{\rightarrow }\cdot 
       \overvar{\sigma }{\rightarrow }}{2\multsp {{(f_{\pi })}^2}}+\DoubleStruckCapitalI \DoubleStruckD \Bigg)
    \rangle$}{If space-time arguments are supplied, the matrices are expanded.}
\domtog{
\mb{CovariantFieldDerivative[IsoDot[\\
    IsoVector[QuantumField[Particle[Pion]]][x],\\
    IsoVector[UMatrix[UGenerator[]]]],x,\\
    LorentzIndex[$\bm{\mu}$]] // CommutatorReduce}
}{
$\partial_\mu\left(\overrightarrow{\pi}\right) \cdot \overrightarrow{\bm{\sigma}}\, +\\
 \ComplexI \left( \overrightarrow{\pi} \cdot
 \overrightarrow{\bm{\sigma}}\, \SixPointedStar\, \left( \overrightarrow{V_\mu} \cdot
               \overrightarrow{\bm{\sigma}} -
                     \overrightarrow{A_\mu} \cdot \overrightarrow{\bm{\sigma}}
                     \right)\right) -
\ComplexI \left( \left( \overrightarrow{V_\mu} \cdot
               \overrightarrow{\bm{\sigma}} +
                     \overrightarrow{A_\mu} \cdot \overrightarrow{\bm{\sigma}}
                     \right)\, \SixPointedStar\,  \overrightarrow{\pi} \cdot
\overrightarrow{\bm{\sigma}} \right) \, +\\
\ComplexI \left( \overrightarrow{\pi} \cdot
 \overrightarrow{\bm{\sigma}}\, \SixPointedStar\, Q_{\rm\bf L}\right)\, \gamma_\mu\, -\,
\ComplexI \left( Q_{\rm\bf R}\, \SixPointedStar\,  \overrightarrow{\pi} \cdot
 \overrightarrow{\bm{\sigma}} \right)\, \gamma_\mu$
}{
Here is an example, involving also \mb{IsoVector}, \mb{UMatrix}. Notice that
\mb{IsoVector} takes over the $x$-dependence.
}
\domtog{ArgumentsSupply[Lagrangian[ChPTVirtualPhotons2[2]], x, 
  RenormalizationState[0], \\
  ExpansionOrder \bm{$\rightarrow$} 0,\\
  DropOrder \bm{$\rightarrow$} 0]}{
$\frac{1}{4}\multsp 
     \bigg(\langle \bigg(\ImaginaryI \multsp 
       \bigg(\overvar{{{{{V}}}_{\mu }}}{\rightarrow }\cdot 
          \overvar{\sigma }{\rightarrow }-
         \overvar{{{{{A}}}_{\mu }}}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }
          \bigg)-\ImaginaryI \multsp \bigg(
        \overvar{{{{{A}}}_{\mu }}}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }+
         \overvar{{{{{V}}}_{\mu }}}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }
          \bigg)+  \\
 \ImaginaryI \multsp 
      \big({{Q}_{L}}\SixPointedStar {{{{\gamma }}}_{\mu }}\big)-
     \ImaginaryI \multsp \big({{Q}_{R}}\SixPointedStar {{{{\gamma }}}_{\mu }}\big)\bigg)
    \SixPointedStar \bigg(  \\
 -\ImaginaryI \multsp 
    \bigg(\overvar{{{{{V}}}_{\mu }}}{\rightarrow }\cdot 
       \overvar{\sigma }{\rightarrow }-
      \overvar{{{{{A}}}_{\mu }}}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }
       \bigg)+\ImaginaryI \multsp \bigg(
     \overvar{{{{{A}}}_{\mu }}}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }+
      \overvar{{{{{V}}}_{\mu }}}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }
       \bigg)-  \\
\ImaginaryI \multsp 
       \big({{{{\gamma }}}_{\mu }}\SixPointedStar {{{{Q}_{L}}}^{\dagger }}\big)+
      \ImaginaryI \multsp \big({{{{\gamma }}}_{\mu }}\SixPointedStar 
         {{{{Q}_{R}}}^{\dagger }}\big)\bigg)\rangle + 
    4\multsp \ScriptCapitalB _{0}\multsp 
       \bigg(\frac{{{(m_{\pi })}^2}}{\ScriptCapitalB _{0}}+
         2\multsp {{{{s}}}^0}\bigg)\bigg)\multsp {{(f_{\pi })}^2}-  \\
 \frac{1}{4}\multsp 
    \big(\big({{\partial }_{\mu }}{{\gamma }}_{\nu }-
        {{\partial }_{\nu }}{{\gamma }}_{\mu }\big)\SixPointedStar \big(
      {{\partial }_{\mu }}{{\gamma }}_{\nu }-
       {{\partial }_{\nu }}{{\gamma }}_{\mu }\big)\big)+
   {{C}}\multsp \langle {{Q}_{R}}\SixPointedStar {{Q}_{L}}\rangle -  \\
\frac{1}{2}\multsp \lambda \multsp 
   {{\partial }_{\mu }}{{\gamma }}_{\mu }\multsp 
   {{\partial }_{\nu }}{{\gamma }}_{\nu }$}{The previously inspected lagrangian may be expanded in the meson field. For readability we expand only to order 0.}
\enom

\subsection{Power Counting with \fa}

To fully automatize the calculation of amplitudes, a way of generating Feynman diagrams and
corresponding expressions  is needed. The package \fa by H.~Eck, J.~K\"ublbeck and T.~Hahn
is a convenient choice, since it is written in \mma
and is general enough to allow the definition of ChPT models and any number of legs in the
coupling vertices. \fa is documented in ref.~\citen{Hahn:2000kx}.

Two features of ChPT complicates the application of \fa:
1) The expansion is not just in a coupling constant, but in meson masses and momenta and
typically also in a coupling constant.
This makes the "generic" and "classes" coupling concept of \fa a complicating irrelevance.
2) The coupling expressions can be very large. Therefore, the \fa convention of having all
coupling definitions in one file is not practical.

The strategy chosen to deal with these complications is as follows:
\begin{itemize}
\item The functions \mb{MomentaCollect}, \mb{GenericCoupling} and \mb{ClassesCoupling}
are provided, to facilitate the splitting of Feynman rules generated with
\mb{FeynRule} (see section \ref{Green}) into "generic" and "classes" coupling "vectors"
understood by \fa.
\item For a calculation to order $p^{2 n}$, each vertex will in general have contributions of
order $p^2, p^4, ... p^{2 n}$. Ignoring coupling constants for the moment, the generic vector must
then have $2 n$ entries. The classes "vector" consists of $2 n$ $2 n$-dimensional lists,
where the $2 n$th list will have zeros for all but the $2 n$th entry, that is, the classes
"vector" is a diagonal matrix. E.g.~for $n=2$, $\{\{a,0\},\{0,b\}\}$, where $a$ and $b$ are the
$\mathscr{O}(p^2)$ and $\mathscr{O}(p^4)$ couplings.
\item The generic and classes "vectors" are each stored in separate files with extension
".Gen" and ".Mod" respectively, in the directory "HighEnergyPhysics/Phi/CouplingVectors".
A naming convention is followed for these files and
functions, \mb{XName} and  \mb{CheckF}, are provided for generating the correct name
and for storing and retrieving from the directory "HighEnergyPhysics/Phi/CouplingVectors".
\item The \fa model files "Automatic.gen" and "Automatic.mod" load the saved coupling "vectors"
and generate correct \fa model definitions using the information of the active \fphi model.
\end{itemize}

Generating and storing  \fa coupling "vectors" usually follows a standard procedure;
this is exemplified below for the $\gamma \gamma \pi^+ \pi^-$ coupling.

\beom
\dtog{l = ArgumentsSupply[\\
      \mindent\mindent Lagrangian[ChPTVirtualPhotons2[2]], \\
      \mindent\mindent x, RenormalizationState[0], \\
      \mindent\mindent DiagonalToU \bm{$\rightarrow$} True,\\
      \mindent\mindent ExpansionOrder \bm{$\rightarrow$} 2, \\
      \mindent\mindent DropOrder \bm{$\rightarrow$} 2];}{}
      {The lagrangian is now expanded to second order in the
      pion field.}
\domtog{DiscardTerms[l, \\
        Retain \bm{$\rightarrow$} \\
       {ParticleField[Pion , \\
       \mindent RenormalizationState[0]] \bm{$\rightarrow$} 2,\\
        ParticleField[Photon, \\
        \mindent RenormalizationState[0]] \bm{$\rightarrow$} 2},\\
        CommutatorReduce \bm{$\rightarrow$} True, \\
        Method \bm{$\rightarrow$} Expand] /.\\
        \$Substitutions // NMExpand // \\
        CycleUTraces // Expand}{
$\frac{1}{8}\multsp {{({e})}^2}\multsp  \langle \overvar{{{\pi }}}{\rightarrow
}\cdot \overvar{\sigma }{\rightarrow }\SixPointedStar  \overvar{{{\pi
}}}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }\SixPointedStar {{\sigma
}^3}\SixPointedStar  {{\sigma }^3}\rangle \multsp {{\gamma }}_{\mu }^{2}-
\frac{1}{8}\multsp  {{({e})}^2}\multsp \langle \overvar{{{\pi }}}{\rightarrow
}\cdot \overvar{\sigma }{\rightarrow }\SixPointedStar {{\sigma }^3} \SixPointedStar
\overvar{{{\pi }}}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }\SixPointedStar
{{\sigma }^3}\rangle  \multsp {{\gamma }}_{\mu }^{2}$}{Terms of order in the pion field
different from 2 are discarded. Default substitutions are applied, cyclicity of the trace
is used, some expansion is done.}
\domtog{ExpandU[\%, CommutatorReduce \bm{$\rightarrow$} True] // Simplify}{$\frac{1}{4}\multsp {{({e})}^2}\multsp \bigg(-{{\big(
\overvar{\DoubleStruckP (3)}{\rightarrow }\cdot \overvar{{{\pi
}}}{\rightarrow }\big)}^2}+ \overvar{\DoubleStruckP
(3)}{\rightarrow }\times \overvar{{{\pi }}}{\rightarrow }\cdot
\overvar{\DoubleStruckP (3)}{\rightarrow }\times \overvar{{{\pi }}}{\rightarrow }+
\overvar{{{\pi }}}{\rightarrow }\cdot
\overvar{{{\pi }}}{\rightarrow }\bigg)\multsp {{\gamma }}_{\mu
}^{2}$}{Monomials in $\overvar{{{\pi }}}{\rightarrow }\cdot \overvar{\sigma }{\rightarrow }$
are reduced to monomials of order 0 or 1, using the commutation and anti-commutation relations
of the generator matrices.}
\domtog{ll = \% // IsoIndicesSupply // \\
SUNReduce // IndicesCleanup // \\
      CommutatorReduce // Simplify}{$\frac{1}{4}\multsp {{({{e}})}^2}\multsp 
   {{{{\pi }}}^{{{k}_1}}}\multsp
 \big(
    -\delta _{3{{k}_1}}^{(2)}\multsp {{{{\pi }}}^3}+{{{{\pi }}}^{{{k}_1}}}-
     \delta _{3{{k}_3}}^{(2)}\multsp f_{3{{k}_1}{{k}_4}}^{(2)}\multsp 
      f_{{{k}_2}{{k}_3}{{k}_4}}^{(2)}\multsp {{{{\pi }}}^{{{k}_2}}}\big)\multsp  
{{\gamma }}_{\Mvariable{\rho 1}}^{2}$}{The vector products are written in terms of contracted indices. Some simplification is done.}
\domtog{fields = {QuantumField[Particle[Pion, RenormalizationState[0]], 
        SUNIndex[I1]][p1], 
    QuantumField[Particle[Pion, RenormalizationState[0]], 
        SUNIndex[I2]][p2], 
    QuantumField[Particle[Photon, RenormalizationState[0]], 
        LorentzIndex[\bm{$\mu$}3]][p3], 
    QuantumField[Particle[Photon, RenormalizationState[0]], 
        LorentzIndex[\bm{$\mu$}4]][p4]}}{$\big\{{{{{\pi }}}^{{{I}_1}}},{{{{\pi }}}^{{{I}_2}}},
    {{{{\gamma }}}_{{{\mu }_3}}},{{{{\gamma }}}_{{{\mu }_4}}}\big\}$}{The fields of the vertex are defined.}
\domtog{m = FeynRule[ll, fields] //\\
        SUNReduce[\#, FullReduce \bm{$\rightarrow$} True] \& // \\
        IndicesCleanup // CommutatorReduce // \\
        Simplify}{$-2\multsp \ImaginaryI \multsp {{({{e}})}^2}\multsp {g^{{{\mu }_3}{{\mu }_4}}}\multsp 
   \big(\delta _{3{{I}_1}}^{(2)}\multsp \delta _{3{{I}_2}}^{(2)}-
     \delta _{{{I}_1}{{I}_2}}^{(2)}\big)$}
{The Feynman rule is calculated and reduced.}
\domtog{mfa = MomentaCollect[m // Expand, PerturbationOrder \bm{$\rightarrow$} 2]}{${{({{e}})}^2}\multsp {g^{{{\mu }_3}{{\mu }_4}}}\multsp 
   \big(2\multsp \ImaginaryI \multsp \delta _{{{I}_1}{{I}_2}}^{(2)}-
     2\multsp \ImaginaryI \multsp \delta _{3{{I}_1}}^{(2)}\multsp 
      \delta _{3{{I}_2}}^{(2)}\big)$}
{The terms are collected according to powers of the chiral expansion parameters. In this
particular case this step is redundant.}
\domtog{gencoup = GenericCoupling[mfa]}{$\big\{{{({{e}})}^2}\multsp {g^{{{\mu }_3}{{\mu
}_4}}}\big\}$}
{The generic coupling vector is generated.}
\domtog{classcoup = ClassesCoupling[mfa] // Together; classcoup // StandardForm}{$\{\{-2\multsp
\ImaginaryI \multsp (\Muserfunction{SUNDelta}[3,\Mvariable{I1}]\multsp
        \Muserfunction{SUNDelta}[3,\Mvariable{I2}]-
       \Muserfunction{SUNDelta}[\Mvariable{I1},\Mvariable{I2}])\}\}$}
{The classes coupling "vector" is generated.}
\dtog{CheckF[gencoup, 
    XName[PhiModel \bm{$\rightarrow$} ChPTVirtualPhotons2, 
        VertexFields \bm{$\rightarrow$} {Pion[0], Pion[0], Photon[0],
             Photon[0]}, \\
             PerturbationOrder \bm{$\rightarrow$} 2] <> 
      ".Gen"];}{}{The generic coupling vector is saved.}
\dtog{CheckF[classcoup, 
    XName[PhiModel \bm{$\rightarrow$} ChPTVirtualPhotons2, 
        VertexFields \bm{$\rightarrow$} {Pion[0], Pion[0], Photon[0],
             Photon[0]}, \\
             PerturbationOrder \bm{$\rightarrow$} 2] <> 
      ".Mod"];}{}{The classes coupling "vector" is saved.}
\dtog{Clear[l,ll,m,mfa];}{}{Clean up.}
\enom

\otabtwo{
\mbs{\$Substitutions} & a list of substitution rules, defined by the active \fphi configuration
file, used to write out predefined lagrangians beyond what is done by \mb{ArgumentsSupply}\cr
}{Expansion of predefined lagrangians.}

When the $\gamma \gamma \pi^+ \pi^-$ coupling has been calculated, transformed to the right
format and stored in the right place, it is ready for use by \fa through the model files
"Automatic.gen" and "Automatic.mod". Also, when \fphi is loaded, the database of amplitudes
accessible through the function \mb{Amplitude} is enlarged with all amplitudes calculated and
stored as above.

\beom
\domtog{Amplitude["ChPTVirtualPhotons2P20P20V10V10o2"]}{$-2\multsp \ImaginaryI \multsp
{{({{e}})}^2}\multsp {g^{{{\mu }_3}{{\mu }_4}}}\multsp 
   ({{\delta }_{3\Mvariable{I1}}}\multsp {{\delta }_{3\Mvariable{I2}}}-
     {{\delta }_{\Mvariable{I1}\Mvariable{I2}}})$}{We may, for example, inspect the $\gamma \gamma
     \pi^+ \pi^-$ coupling.}
\enom

\otabtwo{
\mbs{MomentaCollect[{\sl l}]} & collects terms of {\sl l} according to their order in the
perturbation expansion\cr
\mbs{GenericCoupling[{\sl m}]} & constructs the kinematical coupling vector to
be used in a generic model file for \fa from the matrix element {\sl m}\cr
\mbs{ClassesCoupling[{\sl l}]} & constructs the kinematical coupling "vector" to
be used in a classes model file for \fa from the matrix element {\sl m}\cr
\mbs{XName[{\sl opts}]} & generates a name for a coupling file, using the options {\sl opts}\cr
\mbs{CheckF[{\sl exp}, {\sl fil}]} & checks if {\sl fil} exists.  If it does, gets {\sl fil} and
returns the loaded expressions.
If {\sl fil} does not exist, evaluates {\sl exp}, saves it to {\sl fil} and returns the
evaluated {\sl exp}\cr
}{Utilities for generating and storing \fa coupling "vectors".}

\otabthree{
{\sl option name} & {\sl default value} &\cr
\hhline
\mbs{ParticlesNumber} & \mb{4} &  number of particles in the vertex\cr
\mbs{PerturbationOrder} & \mb{2} & order in the perturbation expansion\cr
\mbs{MomentumVariables String } & \mb{"p"} & base string of the momenta names, e.g.~\mb{p1}, \mb{p2}, ... \cr
\mbs{VertexFields} & \mb{\{Pion[0], Pion[0], Pion[0], Pion[0]\}} & fields in the vertex\cr
\mbs{PhiModel} & \mb{ChPT2} & \fphi model\cr
\mbs{Directory} & \mb{"Phi/Storage"} & storage directory\cr
\mbs{ForceSave} & \mb{False} & evaluate and save even if the file already exists\cr
}{Options controlling the utilities for generating \fa coupling vectors.}


\subsection{Example: Radiative Pion Decay}

$\pi^\pm \, \rightarrow  \, \mu^\pm \, \nu_\mu \, \gamma$

